{"meta":{"title":"Rohmi's blog","subtitle":null,"description":"프론트엔드 개발자 로미의 블로그입니다.","author":null,"url":"https://rohmikwon.github.io"},"pages":[{"title":"","date":"2017-07-23T06:47:55.824Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"index.html","permalink":"https://rohmikwon.github.io/index.html","excerpt":"","text":""},{"title":"About","date":"2017-07-23T07:55:34.907Z","updated":"2017-07-11T19:16:46.000Z","comments":true,"path":"about/index.html","permalink":"https://rohmikwon.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-23T06:47:55.835Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"menu/index.html","permalink":"https://rohmikwon.github.io/menu/index.html","excerpt":"","text":""},{"title":"Performance Comparisons","date":"2017-07-23T06:47:55.836Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"perf/index.html","permalink":"https://rohmikwon.github.io/perf/index.html","excerpt":"","text":"TodoMVC Benchmark Last Updated: 2014-10-12 Looking for the TodoMVC Benchmark? It’s been removed because after discussion with some other framework authors we have agreed that: The original intention of these benchmarks were for comparing Browser performance rather than that of frameworks. The “synchrorously trigger an action xxx times” test routine doesn’t reflect meaningful real world user actions. Due to internal implementation differences, frameworks that uses async rendering (e.g. Vue, Om, Mercury) gains the advantage by skipping part of the calculations that happened in the same event loop. The real world user experience doesn’t demonstrate such dramatic difference. Overall this benchmark suite gave rise to more controversy than constructive insights, so it’s been removed and I’d be happy to replace it with a more meaningful way to measure front-end performance."},{"title":"","date":"2017-07-23T06:47:55.837Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"support-vuejs/index.html","permalink":"https://rohmikwon.github.io/support-vuejs/index.html","excerpt":"","text":"Support Vue.js DevelopmentVue.js is an MIT licensed open source project and completely free to use.However, the amount of effort needed to maintain and develop new features for the project is not sustainable without proper financial backing. You can support Vue.js development by pledging on Patreon (recurring, with perks for different tiers) or donating on PayPal (one time). Current Premium Sponsors:Platinum ($2000/mo) Gold ($500/mo) If you run a business and are using Vue in a revenue-generating product, it makes business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers. If you are a business that is building core products using Vue.js, I am also open to conversations regarding custom sponsorship / consulting arrangements. Get in touch on Twitter. If you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)"},{"title":"Tags","date":"2017-07-23T07:55:34.910Z","updated":"2017-07-11T19:16:46.000Z","comments":true,"path":"tags/index.html","permalink":"https://rohmikwon.github.io/tags/index.html","excerpt":"","text":""},{"title":"Project","date":"2017-07-23T07:55:34.909Z","updated":"2017-07-11T19:16:46.000Z","comments":true,"path":"project/index.html","permalink":"https://rohmikwon.github.io/project/index.html","excerpt":"","text":""},{"title":"Adding Instance Properties","date":"2017-07-23T06:47:55.841Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/cookbook/adding-instance-properties.html","permalink":"https://rohmikwon.github.io/v2/cookbook/adding-instance-properties.html","excerpt":"","text":"Simple ExampleThere may be data/utilities you’d like to use in many components, but you don’t want to pollute the global scope. In these cases, you can make them available to each Vue instance by defining them on the prototype: Vue.prototype.$appName = 'My App' Now $appName is available on all Vue instances, even before creation. If we run: new Vue(&#123; beforeCreate: function () &#123; console.log(this.$appName) &#125;&#125;) Then &quot;My App&quot; will be logged to the console. It’s that simple! The Importance of Scoping Instance PropertiesYou may be wondering: “Why does appName start with $? Is that important? What does it do? No magic is happening here. $ is simply a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods. “Conflicts? What do you mean?” Another great question! If you just set: Vue.prototype.appName = 'My App' Then what would you expect to be logged below? new Vue(&#123; data: &#123; // Uh oh - appName is *also* the name of the // instance property we just defined! appName: 'The name of some other app' &#125;, beforeCreate: function () &#123; console.log(this.appName) &#125;, created: function () &#123; console.log(this.appName) &#125;&#125;) It would be &quot;The name of some other app&quot;, then &quot;My App&quot;, because this.appName is overwritten (sort of) by data when the instance is created. We scope instance properties with $ to avoid this. You can even use your own convention if you’d like, such as $_appName or ΩappName, to prevent even conflicts with plugins or future features. Real-World Example: Replacing Vue Resource with AxiosLet’s say you’re replacing the now-retired Vue Resource. You really enjoyed accessing request methods through this.$http and you want to do the same thing with Axios instead. All you have to do is include axios in your project: &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"user in users\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; Alias axios to Vue.prototype.$http: Vue.prototype.$http = axios Then you’ll be able to use methods like this.$http.get in any Vue instance: new Vue(&#123; el: '#app', data: &#123; users: [] &#125;, created () &#123; var vm = this this.$http.get('https://jsonplaceholder.typicode.com/users') .then(function (response) &#123; vm.users = response.data &#125;) &#125;&#125;) The Context of Prototype MethodsIn case you’re not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use this to access data, computed properties, methods, or anything else defined on the instance. Let’s take advantage of this in a $reverseText method: Vue.prototype.$reverseText = function (propertyName) &#123; this[propertyName] = this[propertyName].split('').reverse().join('')&#125;new Vue(&#123; data: &#123; message: 'Hello' &#125;, created: function () &#123; console.log(this.message) // =&gt; \"Hello\" this.$reverseText('message') console.log(this.message) // =&gt; \"olleH\" &#125;&#125;) Note that the context binding will not work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version: Vue.prototype.$reverseText = propertyName =&gt; &#123; this[propertyName] = this[propertyName].split('').reverse().join('')&#125; Would throw an error: Uncaught TypeError: Cannot read property &apos;split&apos; of undefined When To Avoid This PatternAs long as you’re vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs. However, it can sometimes cause confusion with other developers. They might see this.$http, for example, and think, “Oh, I didn’t know about this Vue feature!” Then they move to a different project and are confused when this.$http is undefined. Or, maybe they want to Google how to do something, but can’t find results because they don’t realize they’re actually using Axios under an alias. The convenience comes at the cost of explicitness. When just looking at a component, it’s impossible to tell where $http came from. Vue itself? A plugin? A coworker? So what are the alternatives? Alternative PatternsWhen Not Using a Module SystemIn applications with no module system (e.g. via Webpack or Browserify), there’s a pattern that’s often used with any JavaScript-enhanced frontend: a global App object. If what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here’s an example: var App = Object.freeze(&#123; name: 'My App', description: '2.1.4', helpers: &#123; // This is a purely functional version of // the $reverseText method we saw earlier reverseText: function (text) &#123; return text.split('').reverse().join('') &#125; &#125;&#125;) If you raised an eyebrow at Object.freeze, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs. Now the source of these shared properties is much more obvious: there’s an App object defined somewhere in the app. To find it, developers need only run a project-wide search. Another advantage is that App can now be used anywhere in your code, whether it’s Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on this: new Vue(&#123; data: &#123; appVersion: App.version &#125;, methods: &#123; reverseText: App.helpers.reverseText &#125;&#125;) When Using a Module SystemWhen you have access to a module system, you can easily organize shared code into modules, then require/import those modules wherever they’re needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know exactly each one came from. While certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app."},{"title":"GitHub Commits","date":"2017-07-23T06:47:55.843Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/commits.html","permalink":"https://rohmikwon.github.io/v2/examples/commits.html","excerpt":"","text":"This example fetches latest Vue.js commits data from GitHub’s API and displays them as a list. You can switch between the master and dev branches."},{"title":"Introduction","date":"2017-07-23T06:47:55.841Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/cookbook/index.html","permalink":"https://rohmikwon.github.io/v2/cookbook/index.html","excerpt":"","text":"WORK IN PROGRESSThis cookbook is still in its very early stages. At this point, we will not be linking to it from anywhere else. Pages may be removed or reorganized at any time. Even the goals and overall format are still in flux. The Cookbook vs the GuideHow is the cookbook different from the guide? Why is this necessary? Greater Focus: In the guide, we’re essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview. Greater Depth: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche. Teaching JavaScript: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won’t explain how Array.prototype.filter works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications. Exploring the Ecosystem: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don’t explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers. Guidelines for RecipesRecipes should generally: Solve a specific, common problem Start with the simplest possible example Introduce complexities one at a time Link to other docs, rather than re-explaining concepts Describe the problem, rather than assuming familiarity Explain the process, rather than just the end result Explain the pros and cons of your strategy, including when it is and isn’t appropriate Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe"},{"title":"Firebase + Validation","date":"2017-07-23T06:47:55.845Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/firebase.html","permalink":"https://rohmikwon.github.io/v2/examples/firebase.html","excerpt":"","text":"This example uses Firebase as the data persistence backend and syncs between clients in real time (you can try opening it in multiple browser tabs). In addition, it performs instant validation using computed properties and triggers CSS transitions when adding/removing items."},{"title":"Elastic Header","date":"2017-07-23T06:47:55.844Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/elastic-header.html","permalink":"https://rohmikwon.github.io/v2/examples/elastic-header.html","excerpt":"","text":""},{"title":"Realtime with deepstreamHub","date":"2017-07-23T06:47:55.843Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/deepstream.html","permalink":"https://rohmikwon.github.io/v2/examples/deepstream.html","excerpt":"","text":"This example uses deepstreamHub to synchronize realtime data, send events and make remote procedure calls between clients (you can try opening it in multiple browser windows)."},{"title":"HackerNews Clone","date":"2017-07-23T06:47:55.846Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/hackernews.html","permalink":"https://rohmikwon.github.io/v2/examples/hackernews.html","excerpt":"","text":"This is a HackerNews clone built upon HN’s official Firebase API, Vue 2.0 + vue-router + vuex, with server-side rendering. Live DemoNote: the demo may need some spin up time if nobody has accessed it for a certain period. [Source] Features Server Side Rendering Vue + vue-router + vuex working together Server-side data pre-fetching Client-side state &amp; DOM hydration Single-file Vue Components Hot-reload in development CSS extraction for production Real-time List Updates with FLIP Animation Architecture Overview"},{"title":"Grid Component","date":"2017-07-23T06:47:55.845Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/grid-component.html","permalink":"https://rohmikwon.github.io/v2/examples/grid-component.html","excerpt":"","text":"This is an example of creating a reusable grid component and using it with external data."},{"title":"Modal Component","date":"2017-07-23T06:47:55.847Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/modal.html","permalink":"https://rohmikwon.github.io/v2/examples/modal.html","excerpt":"","text":"Features used: component, prop passing, content insertion, transitions."},{"title":"Markdown Editor","date":"2017-07-23T06:47:55.847Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/index.html","permalink":"https://rohmikwon.github.io/v2/examples/index.html","excerpt":"","text":"Dead simple Markdown editor."},{"title":"SVG Graph","date":"2017-07-23T06:47:55.848Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/svg.html","permalink":"https://rohmikwon.github.io/v2/examples/svg.html","excerpt":"","text":"This example showcases a combination of custom component, computed property, two-way binding and SVG support."},{"title":"Wrapper Component","date":"2017-07-23T06:47:55.848Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/select2.html","permalink":"https://rohmikwon.github.io/v2/examples/select2.html","excerpt":"","text":"In this example we are integrating a 3rd party jQuery plugin (select2) by wrapping it inside a custom component."},{"title":"Class and Style Bindings","date":"2017-07-23T06:47:55.851Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/class-and-style.html","permalink":"https://rohmikwon.github.io/v2/guide/class-and-style.html","excerpt":"","text":"A common need for data binding is manipulating an element’s class list and its inline styles. Since they are both attributes, we can use v-bind to handle them: we just need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when v-bind is used with class and style. In addition to strings, the expressions can also evaluate to objects or arrays. Binding HTML ClassesObject SyntaxWe can pass an object to v-bind:class to dynamically toggle classes: &lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; The above syntax means the presence of the active class will be determined by the truthiness of the data property isActive. You can have multiple classes toggled by having more fields in the object. In addition, the v-bind:class directive can also co-exist with the plain class attribute. So given the following template: &lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; And the following data: data: &#123; isActive: true, hasError: false&#125; It will render: &lt;div class=\"static active\"&gt;&lt;/div&gt; When isActive or hasError changes, the class list will be updated accordingly. For example, if hasError becomes true, the class list will become &quot;static active text-danger&quot;. The bound object doesn’t have to be inline: &lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; This will render the same result. We can also bind to a computed property that returns an object. This is a common and powerful pattern: &lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal', &#125; &#125;&#125; Array SyntaxWe can pass an array to v-bind:class to apply a list of classes: &lt;div v-bind:class=\"[activeClass, errorClass]\"&gt; data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; Which will render: &lt;div class=\"active text-danger\"&gt;&lt;/div&gt; If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression: &lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt; This will always apply errorClass, but will only apply activeClass when isActive is true. However, this can be a bit verbose if you have multiple conditional classes. That’s why it’s also possible to use the object syntax inside array syntax: &lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt; With Components This section assumes knowledge of Vue Components. Feel free to skip it and come back later. When you use the class attribute on a custom component, those classes will be added to the component’s root element. Existing classes on this element will not be overwritten. For example, if you declare this component: Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;) Then add some classes when using it: &lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt; The rendered HTML will be: &lt;p class=\"foo bar baz boo\"&gt;Hi&lt;/p&gt; The same is true for class bindings: &lt;my-component v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/my-component&gt; When isActive is truthy, the rendered HTML will be: &lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; Binding Inline StylesObject SyntaxThe object syntax for v-bind:style is pretty straightforward - it looks almost like CSS, except it’s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names: &lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt; data: &#123; activeColor: 'red', fontSize: 30&#125; It is often a good idea to bind to a style object directly so that the template is cleaner: &lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; Again, the object syntax is often used in conjunction with computed properties that return objects. Array SyntaxThe array syntax for v-bind:style allows you to apply multiple style objects to the same element: &lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt; Auto-prefixingWhen you use a CSS property that requires vendor prefixes in v-bind:style, for example transform, Vue will automatically detect and add appropriate prefixes to the applied styles. Multiple Values 2.3.0+ Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example: &lt;div v-bind:style=\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"&gt; This will only render the last value in the array which the browser supports. In this example, it will render display: flex for browsers that support the unprefixed version of flexbox."},{"title":"Tree View","date":"2017-07-23T06:47:55.849Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/tree-view.html","permalink":"https://rohmikwon.github.io/v2/examples/tree-view.html","excerpt":"","text":"Example of a simple tree view implementation showcasing recursive usage of components."},{"title":"Components","date":"2017-07-23T06:47:55.852Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/components.html","permalink":"https://rohmikwon.github.io/v2/guide/components.html","excerpt":"","text":"What are Components?Components are one of the most powerful features of Vue. They help you extend basic HTML elements to encapsulate reusable code. At a high level, components are custom elements that Vue’s compiler attaches behavior to. In some cases, they may also appear as a native HTML element extended with the special is attribute. Using ComponentsRegistrationWe’ve learned in the previous sections that we can create a new Vue instance with: new Vue(&#123; el: '#some-element', // options&#125;) To register a global component, you can use Vue.component(tagName, options). For example: Vue.component('my-component', &#123; // options&#125;) Note that Vue does not enforce the W3C rules for custom tag names (all-lowercase, must contain a hyphen) though following this convention is considered good practice. Once registered, a component can be used in an instance’s template as a custom element, &lt;my-component&gt;&lt;/my-component&gt;. Make sure the component is registered before you instantiate the root Vue instance. Here’s the full example: &lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; // registerVue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// create a root instancenew Vue(&#123; el: '#example'&#125;) Which will render: &lt;div id=\"example\"&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; Vue.component('my-component', { template: 'A custom component!' }) new Vue({ el: '#example' }) Local RegistrationYou don’t have to register every component globally. You can make a component available only in the scope of another instance/component by registering it with the components instance option: var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; will only be available in parent's template 'my-component': Child &#125;&#125;) The same encapsulation applies for other registerable Vue features, such as directives. DOM Template Parsing CaveatsWhen using the DOM as your template (e.g. using the el option to mount an element with existing content), you will be subject to some restrictions that are inherent to how HTML works, because Vue can only retrieve the template content after the browser has parsed and normalized it. Most notably, some elements such as &lt;ul&gt;, &lt;ol&gt;, &lt;table&gt; and &lt;select&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;option&gt; can only appear inside certain other elements. This will lead to issues when using custom components with elements that have such restrictions, for example: &lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; The custom component &lt;my-row&gt; will be hoisted out as invalid content, thus causing errors in the eventual rendered output. A workaround is to use the is special attribute: &lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; It should be noted that these limitations do not apply if you are using string templates from one of the following sources: &lt;script type=&quot;text/x-template&quot;&gt; JavaScript inline template strings .vue components Therefore, prefer using string templates whenever possible. data Must Be a FunctionMost of the options that can be passed into the Vue constructor can be used in a component, with one special case: data must be function. In fact, if you try this: Vue.component('my-component', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: &#123; message: 'hello' &#125;&#125;) Then Vue will halt and emit warnings in the console, telling you that data must be a function for component instances. It’s good to understand why the rules exist though, so let’s cheat. &lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // data is technically a function, so Vue won't // complain, but we return the same object // reference for each component instance data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) var data = { counter: 0 } Vue.component('simple-counter', { template: '{{ counter }}', data: function () { return data } }) new Vue({ el: '#example-2' }) Since all three component instances share the same data object, incrementing one counter increments them all! Ouch. Let’s fix this by instead returning a fresh data object: data: function () &#123; return &#123; counter: 0 &#125;&#125; Now all our counters each have their own internal state: Vue.component('my-component', { template: '{{ counter }}', data: function () { return { counter: 0 } } }) new Vue({ el: '#example-2-5' }) Composing ComponentsComponents are meant to be used together, most commonly in parent-child relationships: component A may use component B in its own template. They inevitably need to communicate to one another: the parent may need to pass data down to the child, and the child may need to inform the parent of something that happened in the child. However, it is also very important to keep the parent and the child as decoupled as possible via a clearly-defined interface. This ensures each component’s code can be written and reasoned about in relative isolation, thus making them more maintainable and potentially easier to reuse. In Vue, the parent-child component relationship can be summarized as props down, events up. The parent passes data down to the child via props, and the child sends messages to the parent via events. Let’s see how they work next. PropsPassing Data with PropsEvery component instance has its own isolated scope. This means you cannot (and should not) directly reference parent data in a child component’s template. Data can be passed down to child components using props. A prop is a custom attribute for passing information from parent components. A child component needs to explicitly declare the props it expects to receive using the props option: Vue.component('child', &#123; // declare the props props: ['message'], // just like data, the prop can be used inside templates // and is also made available in the vm as this.message template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) Then we can pass a plain string to it like so: &lt;child message=\"hello!\"&gt;&lt;/child&gt; Result: new Vue({ el: '#prop-example-1', components: { child: { props: ['message'], template: '{{ message }}' } } }) camelCase vs. kebab-caseHTML attributes are case-insensitive, so when using non-string templates, camelCased prop names need to use their kebab-case (hyphen-delimited) equivalents: Vue.component('child', &#123; // camelCase in JavaScript props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;) &lt;!-- kebab-case in HTML --&gt;&lt;child my-message=\"hello!\"&gt;&lt;/child&gt; Again, if you’re using string templates, then this limitation does not apply. Dynamic PropsSimilar to binding a normal attribute to an expression, we can also use v-bind for dynamically binding props to data on the parent. Whenever the data is updated in the parent, it will also flow down to the child: &lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; It’s often simpler to use the shorthand syntax for v-bind: &lt;child :my-message=\"parentMsg\"&gt;&lt;/child&gt; Result: new Vue({ el: '#demo-2', data: { parentMsg: 'Message from parent' }, components: { child: { props: ['myMessage'], template: '{{myMessage}}' } } }) Literal vs. DynamicA common mistake beginners tend to make is attempting to pass down a number using the literal syntax: &lt;!-- this passes down a plain string \"1\" --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt; However, since this is a literal prop, its value is passed down as a plain string &quot;1&quot; instead of an actual number. If we want to pass down an actual JavaScript number, we need to use v-bind so that its value is evaluated as a JavaScript expression: &lt;!-- this passes down an actual number --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; One-Way Data FlowAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to reason about. In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console. There are usually two cases where it’s tempting to mutate a prop: The prop is used to only pass in an initial value, the child component simply wants to use it as a local data property afterwards; The prop is passed in as a raw value that needs to be transformed. The proper answer to these use cases are: Define a local data property that uses the prop’s initial value as its initial value: props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; Define a computed property that is computed from the prop’s value: props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child will affect parent state. Prop ValidationIt is possible for a component to specify requirements for the props it is receiving. If a requirement is not met, Vue will emit warnings. This is especially useful when you are authoring a component that is intended to be used by others. Instead of defining the props as an array of strings, you can use an object with validation requirements: Vue.component('example', &#123; props: &#123; // basic type check (`null` means accept any type) propA: Number, // multiple possible types propB: [String, Number], // a required string propC: &#123; type: String, required: true &#125;, // a number with default value propD: &#123; type: Number, default: 100 &#125;, // object/array defaults should be returned from a // factory function propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // custom validator function propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) The type can be one of the following native constructors: String Number Boolean Function Object Array Symbol In addition, type can also be a custom constructor function and the assertion will be made with an instanceof check. When prop validation fails, Vue will produce a console warning (if using the development build). Note that props are validated before a component instance is created, so within default or validator functions, instance properties such as from data, computed, or methods will not be available. Non-Prop AttributesA non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined. While explicitly defined props are preferred for passing information to a child component, authors of component libraries can’t always foresee the contexts in which their components might be used. That’s why components can accept arbitrary attributes, which are added to the component’s root element. For example, imagine we’re using a 3rd-party bs-date-input component with a Bootstrap plugin that requires a data-3d-date-picker attribute on the input. We can add this attribute to our component instance: &lt;bs-date-input data-3d-date-picker=\"true\"&gt;&lt;/bs-date-input&gt; And the data-3d-date-picker=&quot;true&quot; attribute will automatically be added to the root element of bs-date-input. Replacing/Merging with Existing AttributesImagine this is the template for bs-date-input: &lt;input type=\"date\" class=\"form-control\"&gt; To add specify a theme for our date picker plugin, we might need to add a specific class, like this: &lt;bs-date-input data-3d-date-picker=\"true\" class=\"date-picker-theme-dark\"&gt;&lt;/bs-date-input&gt; In this case, two different values for class are defined: form-control, which is set by the component in its template date-picker-theme-dark, which is passed to the component by its parent For most attributes, the value provided to the component will replace the value set by the component. So for example, passing type=&quot;large&quot; will replace type=&quot;date&quot; and probably break it! Fortunately, the class and style attributes are a little smarter, so both values are merged, making the final value: form-control date-picker-theme-dark. Custom EventsWe have learned that the parent can pass data down to the child using props, but how do we communicate back to the parent when something happens? This is where Vue’s custom event system comes in. Using v-on with Custom EventsEvery Vue instance implements an events interface, which means it can: Listen to an event using $on(eventName) Trigger an event using $emit(eventName) Note that Vue’s event system is separate from the browser’s EventTarget API. Though they work similarly, $on and $emit are not aliases for addEventListener and dispatchEvent. In addition, a parent component can listen to the events emitted from a child component using v-on directly in the template where the child component is used. You cannot use $on to listen to events emitted by children. You must use v-on directly in the template, as in the example below. Here’s an example: &lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt; Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) {{ total }} Vue.component('button-counter', { template: '{{ counter }}', data: function () { return { counter: 0 } }, methods: { increment: function () { this.counter += 1 this.$emit('increment') } } }) new Vue({ el: '#counter-event-example', data: { total: 0 }, methods: { incrementTotal: function () { this.total += 1 } } }) In this example, it’s important to note that the child component is still completely decoupled from what happens outside of it. All it does is report information about its own activity, just in case a parent component might care. Binding Native Events to ComponentsThere may be times when you want to listen for a native event on the root element of a component. In these cases, you can use the .native modifier for v-on. For example: &lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; .sync Modifier 2.3.0+ In some cases we may need “two-way binding” for a prop - in fact, in Vue 1.x this is exactly what the .sync modifier provided. When a child component mutates a prop that has .sync, the value change will be reflected in the parent. This is convenient, however it leads to maintenance issues in the long run because it breaks the one-way data flow assumption: the code that mutates child props are implicitly affecting parent state. This is why we removed the .sync modifier when 2.0 was released. However, we’ve found that there are indeed cases where it could be useful, especially when shipping reusable components. What we need to change is making the code in the child that affects parent state more consistent and explicit. In 2.3.0+ we re-introduced the .sync modifier for props, but this time it is just syntax sugar that automatically expands into an additional v-on listener: The following &lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt; is expanded into: &lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt; For the child component to update foo‘s value, it needs to explicitly emit an event instead of mutating the prop: this.$emit('update:foo', newValue) Form Input Components using Custom EventsCustom events can also be used to create custom inputs that work with v-model. Remember: &lt;input v-model=\"something\"&gt; is just syntactic sugar for: &lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; When used with a component, this simplifies to: &lt;custom-input :value=\"something\" @input=\"value =&gt; &#123; something = value &#125;\"&gt;&lt;/custom-input&gt; So for a component to work with v-model, it should (these can be configured in 2.2.0+): accept a value prop emit an input event with the new value Let’s see it in action with a very simple currency input: &lt;currency-input v-model=\"price\"&gt;&lt;/currency-input&gt; Vue.component('currency-input', &#123; template: '\\ &lt;span&gt;\\ $\\ &lt;input\\ ref=\"input\"\\ v-bind:value=\"value\"\\ v-on:input=\"updateValue($event.target.value)\"&gt;\\ &lt;/span&gt;\\ ', props: ['value'], methods: &#123; // Instead of updating the value directly, this // method is used to format and place constraints // on the input's value updateValue: function (value) &#123; var formattedValue = value // Remove whitespace on either side .trim() // Shorten to 2 decimal places .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) // If the value was not already normalized, // manually override it to conform if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // Emit the number value through the input event this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;) Vue.component('currency-input', { template: '\\ \\ $\\ \\ \\ ', props: ['value'], methods: { updateValue: function (value) { var formattedValue = value .trim() .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 ) if (formattedValue !== value) { this.$refs.input.value = formattedValue } this.$emit('input', Number(formattedValue)) } } }) new Vue({ el: '#currency-input-example', data: { price: '' } }) The implementation above is pretty naive though. For example, users are allowed to enter multiple periods and even letters sometimes - yuck! So for those that want to see a non-trivial example, here’s a more robust currency filter: Customizing Component v-model New in 2.2.0+ By default, v-model on a component uses value as the prop and input as the event, but some input types such as checkboxes and radio buttons may want to use the value prop for a different purpose. Using the model option can avoid the conflict in such cases: Vue.component('my-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean, // this allows using the `value` prop for a different purpose value: String &#125;, // ...&#125;) &lt;my-checkbox v-model=\"foo\" value=\"some value\"&gt;&lt;/my-checkbox&gt; The above will be equivalent to: &lt;my-checkbox :checked=\"foo\" @change=\"val =&gt; &#123; foo = val &#125;\" value=\"some value\"&gt;&lt;/my-checkbox&gt; Note that you still have to declare the checked prop explicitly. Non Parent-Child CommunicationSometimes two components may need to communicate with one-another but they are not parent/child to each other. In simple scenarios, you can use an empty Vue instance as a central event bus: var bus = new Vue() // in component A's methodbus.$emit('id-selected', 1) // in component B's created hookbus.$on('id-selected', function (id) &#123; // ...&#125;) In more complex cases, you should consider employing a dedicated state-management pattern. Content Distribution with SlotsWhen using components, it is often desired to compose them like this: &lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; There are two things to note here: The &lt;app&gt; component does not know what content it will receive. It is decided by the component using &lt;app&gt;. The &lt;app&gt; component very likely has its own template. To make the composition work, we need a way to interweave the parent “content” and the component’s own template. This is a process called content distribution (or “transclusion” if you are familiar with Angular). Vue.js implements a content distribution API that is modeled after the current Web Components spec draft, using the special &lt;slot&gt; element to serve as distribution outlets for the original content. Compilation ScopeBefore we dig into the API, let’s first clarify which scope the contents are compiled in. Imagine a template like this: &lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; Should the message be bound to the parent’s data or the child data? The answer is the parent. A simple rule of thumb for component scope is: Everything in the parent template is compiled in parent scope; everything in the child template is compiled in child scope. A common mistake is trying to bind a directive to a child property/method in the parent template: &lt;!-- does NOT work --&gt;&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt; Assuming someChildProperty is a property on the child component, the example above would not work. The parent’s template is not aware of the state of a child component. If you need to bind child-scope directives on a component root node, you should do so in the child component’s own template: Vue.component('child-component', &#123; // this does work, because we are in the right scope template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) Similarly, distributed content will be compiled in the parent scope. Single SlotParent content will be discarded unless the child component template contains at least one &lt;slot&gt; outlet. When there is only one slot with no attributes, the entire content fragment will be inserted at its position in the DOM, replacing the slot itself. Anything originally inside the &lt;slot&gt; tags is considered fallback content. Fallback content is compiled in the child scope and will only be displayed if the hosting element is empty and has no content to be inserted. Suppose we have a component called my-component with the following template: &lt;div&gt; &lt;h2&gt;I'm the child title&lt;/h2&gt; &lt;slot&gt; This will only be displayed if there is no content to be distributed. &lt;/slot&gt;&lt;/div&gt; And a parent that uses the component: &lt;div&gt; &lt;h1&gt;I'm the parent title&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; The rendered result will be: &lt;div&gt; &lt;h1&gt;I'm the parent title&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;I'm the child title&lt;/h2&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; Named Slots&lt;slot&gt; elements have a special attribute, name, which can be used to further customize how content should be distributed. You can have multiple slots with different names. A named slot will match any element that has a corresponding slot attribute in the content fragment. There can still be one unnamed slot, which is the default slot that serves as a catch-all outlet for any unmatched content. If there is no default slot, unmatched content will be discarded. For example, suppose we have an app-layout component with the following template: &lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; Parent markup: &lt;app-layout&gt; &lt;h1 slot=\"header\"&gt;Here might be a page title&lt;/h1&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;p slot=\"footer\"&gt;Here's some contact info&lt;/p&gt;&lt;/app-layout&gt; The rendered result will be: &lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; The content distribution API is a very useful mechanism when designing components that are meant to be composed together. Scoped Slots New in 2.1.0+ A scoped slot is a special type of slot that functions as a reusable template (that can be passed data to) instead of already-rendered-elements. In a child component, simply pass data into a slot as if you are passing props to a component: &lt;div class=\"child\"&gt; &lt;slot text=\"hello from child\"&gt;&lt;/slot&gt;&lt;/div&gt; In the parent, a &lt;template&gt; element with a special attribute scope must exist, indicating that it is a template for a scoped slot. The value of scope is the name of a temporary variable that holds the props object passed from the child: &lt;div class=\"parent\"&gt; &lt;child&gt; &lt;template scope=\"props\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; If we render the above, the output will be: &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; A more typical use case for scoped slots would be a list component that allows the component consumer to customize how each item in the list should be rendered: &lt;my-awesome-list :items=\"items\"&gt; &lt;!-- scoped slot can be named too --&gt; &lt;template slot=\"item\" scope=\"props\"&gt; &lt;li class=\"my-fancy-item\"&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt; &lt;/template&gt;&lt;/my-awesome-list&gt; And the template for the list component: &lt;ul&gt; &lt;slot name=\"item\" v-for=\"item in items\" :text=\"item.text\"&gt; &lt;!-- fallback content here --&gt; &lt;/slot&gt;&lt;/ul&gt; Dynamic ComponentsYou can use the same mount point and dynamically switch between multiple components using the reserved &lt;component&gt; element and dynamically bind to its is attribute: var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;) &lt;component v-bind:is=\"currentView\"&gt; &lt;!-- component changes when vm.currentView changes! --&gt;&lt;/component&gt; If you prefer, you can also bind directly to component objects: var Home = &#123; template: '&lt;p&gt;Welcome home!&lt;/p&gt;'&#125;var vm = new Vue(&#123; el: '#example', data: &#123; currentView: Home &#125;&#125;) keep-aliveIf you want to keep the switched-out components in memory so that you can preserve their state or avoid re-rendering, you can wrap a dynamic component in a &lt;keep-alive&gt; element: &lt;keep-alive&gt; &lt;component :is=\"currentView\"&gt; &lt;!-- inactive components will be cached! --&gt; &lt;/component&gt;&lt;/keep-alive&gt; Check out more details on &lt;keep-alive&gt; in the API reference. MiscAuthoring Reusable ComponentsWhen authoring components, it’s good to keep in mind whether you intend to reuse it somewhere else later. It’s OK for one-off components to be tightly coupled, but reusable components should define a clean public interface and make no assumptions about the context it’s used in. The API for a Vue component comes in three parts - props, events, and slots: Props allow the external environment to pass data into the component Events allow the component to trigger side effects in the external environment Slots allow the external environment to compose the component with extra content. With the dedicated shorthand syntaxes for v-bind and v-on, the intents can be clearly and succinctly conveyed in the template: &lt;my-component :foo=\"baz\" :bar=\"qux\" @event-a=\"doThis\" @event-b=\"doThat\"&gt; &lt;img slot=\"icon\" src=\"...\"&gt; &lt;p slot=\"main-text\"&gt;Hello!&lt;/p&gt;&lt;/my-component&gt; Child Component RefsDespite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you have to assign a reference ID to the child component using ref. For example: &lt;div id=\"parent\"&gt; &lt;user-profile ref=\"profile\"&gt;&lt;/user-profile&gt;&lt;/div&gt; var parent = new Vue(&#123; el: '#parent' &#125;)// access child component instancevar child = parent.$refs.profile When ref is used together with v-for, the ref you get will be an array containing the child components mirroring the data source. $refs are only populated after the component has been rendered, and it is not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid using $refs in templates or computed properties. Async ComponentsIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it’s actually needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component actually needs to be rendered and will cache the result for future re-renders. For example: Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // Pass the component definition to the resolve callback resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) The factory function receives a resolve callback, which should be called when you have retrieved your component definition from the server. You can also call reject(reason) to indicate the load has failed. The setTimeout here is simply for demonstration; How to retrieve the component is entirely up to you. One recommended approach is to use async components together with Webpack’s code-splitting feature: Vue.component('async-webpack-example', function (resolve) &#123; // This special require syntax will instruct Webpack to // automatically split your built code into bundles which // are loaded over Ajax requests. require(['./my-async-component'], resolve)&#125;) You can also return a Promise in the factory function, so with Webpack 2 + ES2015 syntax you can do: Vue.component( 'async-webpack-example', () =&gt; import('./my-async-component')) When using local registration, you can also directly provide a function that returns a Promise: new Vue(&#123; // ... components: &#123; 'my-component': () =&gt; import('./my-async-component') &#125;&#125;) If you’re a Browserify user that would like to use async components, its creator has unfortunately made it clear that async loading “is not something that Browserify will ever support.” Officially, at least. The Browserify community has found some workarounds, which may be helpful for existing and complex applications. For all other scenarios, we recommend simply using Webpack for built-in, first-class async support. Advanced Async Components New in 2.3.0+ Starting in 2.3.0+ the async component factory can also return an object of the following format: const AsyncComp = () =&gt; (&#123; // The component to load. Should be a Promise component: import('./MyComp.vue'), // A component to use while the async component is loading loading: LoadingComp, // A component to use if the load fails error: ErrorComp, // Delay before showing the loading component. Default: 200ms. delay: 200, // The error component will be displayed if a timeout is // provided and exceeded. Default: Infinity. timeout: 3000&#125;) Note that when used as a route component in vue-router, these properties will be ignored because async components are resolved upfront before the route navigation happens. You also need to use vue-router 2.4.0+ if you wish to use the above syntax for route components. Component Naming ConventionsWhen registering components (or props), you can use kebab-case, camelCase, or PascalCase. // in a component definitioncomponents: &#123; // register using kebab-case 'kebab-cased-component': &#123; /* ... */ &#125;, // register using camelCase 'camelCasedComponent': &#123; /* ... */ &#125;, // register using PascalCase 'PascalCasedComponent': &#123; /* ... */ &#125;&#125; Within HTML templates though, you have to use the kebab-case equivalents: &lt;!-- always use kebab-case in HTML templates --&gt;&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt; When using string templates however, we’re not bound by HTML’s case-insensitive restrictions. That means even in the template, you can reference your components using: kebab-case camelCase or kebab-case if the component has been defined using camelCase kebab-case, camelCase or PascalCase if the component has been defined using PascalCase components: &#123; 'kebab-cased-component': &#123; /* ... */ &#125;, camelCasedComponent: &#123; /* ... */ &#125;, PascalCasedComponent: &#123; /* ... */ &#125;&#125; &lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;&lt;camelCasedComponent&gt;&lt;/camelCasedComponent&gt;&lt;pascal-cased-component&gt;&lt;/pascal-cased-component&gt;&lt;pascalCasedComponent&gt;&lt;/pascalCasedComponent&gt;&lt;PascalCasedComponent&gt;&lt;/PascalCasedComponent&gt; This means that the PascalCase is the most universal declaration convention and kebab-case is the most universal usage convention. If your component isn’t passed content via slot elements, you can even make it self-closing with a / after the name: &lt;my-component/&gt; Again, this only works within string templates, as self-closing custom elements are not valid HTML and your browser’s native parser will not understand them. Recursive ComponentsComponents can recursively invoke themselves in their own template. However, they can only do so with the name option: name: 'unique-name-of-my-component' When you register a component globally using Vue.component, the global ID is automatically set as the component’s name option. Vue.component('unique-name-of-my-component', &#123; // ...&#125;) If you’re not careful, recursive components can also lead to infinite loops: name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;' A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a v-if that will eventually be false). Circular References Between ComponentsLet’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a tree-folder component with this template: &lt;p&gt; &lt;span&gt;&#123;&#123; folder.name &#125;&#125;&lt;/span&gt; &lt;tree-folder-contents :children=\"folder.children\"/&gt;&lt;/p&gt; Then a tree-folder-contents component with this template: &lt;ul&gt; &lt;li v-for=\"child in children\"&gt; &lt;tree-folder v-if=\"child.children\" :folder=\"child\"/&gt; &lt;span v-else&gt;&#123;&#123; child.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; When you look closely, you’ll see that these components will actually be each other’s descendent and ancestor in the render tree - a paradox! When registering components globally with Vue.component, this paradox is resolved for you automatically. If that’s you, you can stop reading here. However, if you’re requiring/importing components using a module system, e.g. via Webpack or Browserify, you’ll get an error: Failed to mount component: template or render function not defined. To explain what’s happening, I’ll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B eventually, but there’s no need to resolve B first.” In our case, I’ll make that point the tree-folder component. We know the child that creates the paradox is the tree-folder-contents component, so we’ll wait until the beforeCreate lifecycle hook to register it: beforeCreate: function () &#123; this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')&#125; Problem solved! Inline TemplatesWhen the inline-template special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring. &lt;my-component inline-template&gt; &lt;div&gt; &lt;p&gt;These are compiled as the component's own template.&lt;/p&gt; &lt;p&gt;Not parent's transclusion content.&lt;/p&gt; &lt;/div&gt;&lt;/my-component&gt; However, inline-template makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the template option or in a template element in a .vue file. X-TemplatesAnother way to define templates is inside of a script element with the type text/x-template, then referencing the template by an id. For example: &lt;script type=\"text/x-template\" id=\"hello-world-template\"&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; Vue.component('hello-world', &#123; template: '#hello-world-template'&#125;) These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition. Cheap Static Components with v-onceRendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains a lot of static content. In these cases, you can ensure that it’s only evaluated once and then cached by adding the v-once directive to the root element, like this: Vue.component('terms-of-service', &#123; template: '\\ &lt;div v-once&gt;\\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\\ ... a lot of static content ...\\ &lt;/div&gt;\\ '&#125;)"},{"title":"Comparison with Other Frameworks","date":"2017-07-23T06:47:55.851Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/comparison.html","permalink":"https://rohmikwon.github.io/v2/guide/comparison.html","excerpt":"","text":"This is definitely the most difficult page in the guide to write, but we do feel it’s important. Odds are, you’ve had problems you tried to solve and you’ve used another library to solve them. You’re here because you want to know if Vue can solve your specific problems better. That’s what we hope to answer for you. We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn’t believe that, we wouldn’t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React’s vast ecosystem of alternative renderers or Knockout’s browser support back to IE6, we try to list these as well. We’d also like your help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn’t seem quite right, please let us know by opening an issue. ReactReact and Vue share many similarities. They both: utilize a virtual DOM provide reactive and composable view components maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries Being so similar in scope, we’ve put more time into fine-tuning this comparison than any other. We want to ensure not only technical accuracy, but also balance. We point out where React outshines Vue, for example in the richness of their ecosystem and abundance of their custom renderers. With that said, it’s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours. The React community has been instrumental in helping us achieve this balance, with special thanks to Dan Abramov from the React team. He was extremely generous with his time and considerable expertise to help us refine this document until we were both happy with the final result. PerformanceBoth React and Vue offer comparable performance in most commonly seen use cases, with Vue usually slightly ahead due to its lighter-weight Virtual DOM implementation. If you are interested in numbers, you can check out this 3rd party benchmark which focuses on raw rendering/updating performance. Note that this does not take complex component structures into account, so should only be considered a reference rather than a verdict. Optimization EffortsIn React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use PureComponent or implement shouldComponentUpdate whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because PureComponent/shouldComponentUpdate assumes the entire sub tree’s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state. In Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have shouldComponentUpdate automatically implemented for you, without the nested component caveats. Overall this removes the need for a whole class of performance optimizations from the developer’s plate, and allows them to focus more on building the app itself as it scales. HTML &amp; CSSIn React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer. Vue embraces classic web technologies and builds on top of them. To show you what that means, we’ll dive into some examples. JSX vs TemplatesIn React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript. Render functions with JSX have a few advantages: You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope. The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what’s currently available for Vue templates. In Vue, we also have render functions and even support JSX, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own: For many developers who have been working with HTML, templates simply feel more natural to read and write. The preference itself can be somewhat subjective, but if it makes the developer more productive then the benefit is objective. HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue’s reactivity features. It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase. You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates. Some argue that you’d need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn’t mean the user doesn’t need to learn anything - it’s additional syntax on top of plain JavaScript, so it’s easy for anyone familiar with JavaScript to learn, but saying it’s essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. v-on modifiers). The same task can involve a lot more code when using plain JSX or render functions. On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common. Component-Scoped CSSUnless you spread components out over multiple files (for example with CSS Modules), scoping CSS in React is often done via CSS-in-JS solutions. There are many competing solutions out there, each with its own caveats. A common issue is that features such as hover states, media queries, and pseudo-selectors either require heavy dependencies to reinvent what CSS already does - or they simply are not supported. If not optimized carefully, CSS-in-JS can also introduce non-trivial runtime performance cost. Most importantly, it deviates from the experience of authoring normal CSS. Vue on the other hand, gives you full access to CSS within single-file components: &lt;style scoped&gt; @media (min-width: 250px) &#123; .list-container:hover &#123; background: orange; &#125; &#125;&lt;/style&gt; The optional scoped attribute automatically scopes this CSS to your component by adding a unique attribute (such as data-v-21e5b78) to elements and compiling .list-container:hover to something like .list-container[data-v-21e5b78]:hover. If you are already familiar with CSS Modules, Vue single file components also have first-class support for it. Finally, just as with HTML, you also have the option of writing your CSS using any preprocessors (or post-processors) you’d like, allowing you to leverage existing libraries in those ecosystems. You can also perform design-centric operations such as color manipulation during your build process, rather than importing specialized JavaScript libraries that would increase the size of your build and complexity of your application. ScaleScaling UpFor large applications, both Vue and React offer robust routing solutions. The React community has also been very innovative in terms of state management solutions (e.g. Flux/Redux). These state management patterns and even Redux itself can be easily integrated into Vue applications. In fact, Vue has even taken this model a step further with Vuex, an Elm-inspired state management solution that integrates deeply into Vue that we think offers a superior development experience. Another important difference between these offerings is that Vue’s companion libraries for state management and routing (among other concerns) are all officially supported and kept up-to-date with the core library. React instead chooses to leave these concerns to the community, creating a more fragmented ecosystem. Being more popular though, React’s ecosystem is considerably richer than Vue’s. Finally, Vue offers a CLI project generator that makes it trivially easy to start a new project using your choice of build system, including webpack, Browserify, or even no build system. React is also making strides in this area with create-react-app, but it currently has a few limitations: It does not allow any configuration during project generation, while Vue’s project templates allow Yeoman-like customization. It only offers a single template that assumes you’re building a single-page application, while Vue offers a wide variety of templates for various purposes and build systems. It cannot generate projects from user-built templates, which can be especially useful for enterprise environments with pre-established conventions. It’s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project’s needs are very simple and you never need to “eject” to customize your build process, you’ll be able to update it as a dependency. You can read more about the differing philosophy here. Scaling DownReact is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React’s class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it’s absolutely not suitable for production. While Vue scales up just as well as, if not better than React, it also scales down just as well as jQuery. That’s right - all you have to do is drop a single script tag into a page: &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems. Since you don’t need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading the guide to learn enough to build non-trivial applications. Native RenderingReact Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with Weex, a cross-platform UI framework developed by Alibaba Group, which uses Vue as its JavaScript framework runtime. This means with Weex, you can use the same Vue component syntax to author components that can not only be rendered in the Browser, but also natively on iOS and Android! At this moment, Weex is still in active development and is not as mature and battle-tested as React Native, but its development is driven by the production needs of the largest e-commerce business in the world, and the Vue team will also actively collaborate with the Weex team to ensure a smooth experience for Vue developers. With MobXMobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you’re using that combination and are enjoying it, jumping into Vue is probably the next logical step. AngularJS (Angular 1)Some of Vue’s syntax will look very similar to AngularJS (e.g. v-if vs ng-if). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement. ComplexityVue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS. Flexibility and ModularityAngularJS has strong opinions about how your applications should be structured, while Vue is a more flexible, modular solution. While this makes Vue more adaptable to a wide variety of projects, we also recognize that sometimes it’s useful to have some decisions made for you, so that you can just get started coding. That’s why we offer a webpack template that can set you up within minutes, while also granting you access to advanced features such as hot module reloading, linting, CSS extraction, and much more. Data bindingAngularJS uses two-way binding between scopes, while Vue enforces a one-way data flow between components. This makes the flow of data easier to reason about in non-trivial applications. Directives vs ComponentsVue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, there’s a lot of confusion between the two. PerformanceVue has better performance and is much, much easier to optimize because it doesn’t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to “stabilize” if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there’s simply no way to optimize a scope with many watchers. Vue doesn’t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships. Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues. Angular (Formerly known as Angular 2)We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically. TypeScriptAngular essentially requires using TypeScript, given that almost all its documentation and learning resources are TypeScript-based. TypeScript has its obvious benefits - static type checking can be very useful for large-scale applications, and can be a big productivity boost for developers with backgrounds in Java and C#. However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you’d be better off going with Vue instead, since using Angular without TypeScript can be challenging. Finally, although not as deeply integrated with TypeScript as Angular is, Vue also offers official typings and official decorator for those who wish to use TypeScript with Vue. We are also actively collaborating with the TypeScript and VSCode teams at Microsoft to improve the TS/IDE experience for Vue + TS users. Size and PerformanceIn terms of performance, both frameworks are exceptionally fast and there isn’t enough data from real world use cases to make a verdict. However if you are determined to see some numbers, Vue 2.0 seems to be ahead of Angular according to this 3rd party benchmark. Recent versions of Angular, with AOT compilation and tree-shaking, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + vue-router included (~30kb gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by angular-cli (~130kb gzipped). FlexibilityVue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application. Learning CurveTo get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading the guide. Angular’s learning curve is much steeper. The API surface of the framework is simply huge and as a user you will need to familiarize yourself with a lot more concepts before getting productive. Obviously, the complexity of Angular is largely due to its design goal of targeting only large, complex applications - but that does make the framework a lot more difficult for less-experienced developers to pick up. EmberEmber is a full-featured framework that is designed to be highly opinionated. It provides a lot of established conventions and once you are familiar enough with them, it can make you very productive. However, it also means the learning curve is high and flexibility suffers. It’s a trade-off when you try to pick between an opinionated framework and a library with a loosely coupled set of tools that work together. The latter gives you more freedom but also requires you to make more architectural decisions. That said, it would probably make a better comparison between Vue core and Ember’s templating and object model layers: Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties. Vue’s template syntax harnesses the full power of JavaScript expressions, while Handlebars’ expression and helper syntax is intentionally quite limited in comparison. Performance-wise, Vue outperforms Ember by a fair margin, even after the latest Glimmer engine update in Ember 2.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations. KnockoutKnockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue’s. Its browser support is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+. Over time though, Knockout development has slowed and it’s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it’s a very common use case, the interface for passing children to a component feels a little clunky compared to Vue’s. There also seem to be philosophical differences in the API design which if you’re curious, can be demonstrated by how each handles the creation of a simple todo list. It’s definitely somewhat subjective, but many consider Vue’s API to be less complex and better structured. PolymerPolymer is yet another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue’s components can be loosely compared to Polymer’s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don’t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9. In Polymer 1.0, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible. Polymer custom elements are authored in HTML files, which limits you to plain JavaScript/CSS (and language features supported by today’s browsers). In comparison, Vue’s single file components allows you to easily use ES2015+ and any CSS preprocessors you want. When deploying to production, Polymer recommends loading everything on-the-fly with HTML Imports, which assumes browsers implementing the spec, and HTTP/2 support on both server and client. This may or may not be feasible depending on your target audience and deployment environment. In cases where this is not desirable, you will have to use a special tool called Vulcanizer to bundle your Polymer elements. On this front, Vue can combine its async component feature with webpack’s code-splitting feature to easily split out parts of the application bundle to be lazy-loaded. This ensures compatibility with older browsers while retaining great app loading performance. It is also totally feasible to offer deeper integration between Vue with Web Component specs such as Custom Elements and Shadow DOM style encapsulation - however at this moment we are still waiting for the specs to mature and be widely implemented in all mainstream browsers before making any serious commitments. RiotRiot 2.0 provides a similar component-based development model (which is called a “tag” in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages: Transition effect system. Riot has none. A far more powerful router. Riot’s routing API is extremely minimal. Better performance. Riot traverses a DOM tree rather than using a virtual DOM, so suffers from the same performance issues as AngularJS. More mature tooling support. Vue provides official support for webpack and Browserify, while Riot relies on community support for build system integration."},{"title":"Conditional Rendering","date":"2017-07-23T06:47:55.853Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/conditional.html","permalink":"https://rohmikwon.github.io/v2/guide/conditional.html","excerpt":"","text":"v-ifIn string templates, for example Handlebars, we would write a conditional block like this: &lt;!-- Handlebars template --&gt;&#123;&#123;#if ok&#125;&#125; &lt;h1&gt;Yes&lt;/h1&gt;&#123;&#123;/if&#125;&#125; In Vue, we use the v-if directive to achieve the same: &lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; It is also possible to add an “else” block with v-else: &lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; Conditional Groups with v-if on &lt;template&gt;Because v-if is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use v-if on a &lt;template&gt; element, which serves as an invisible wrapper. The final rendered result will not include the &lt;template&gt; element. &lt;template v-if=\"ok\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; v-elseYou can use the v-else directive to indicate an “else block” for v-if: &lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; A v-else element must immediately follow a v-if or a v-else-if element - otherwise it will not be recognized. v-else-if New in 2.1.0+ The v-else-if, as the name suggests, serves as an “else if block” for v-if. It can also be chained multiple times: &lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; Similar to v-else, a v-else-if element must immediately follow a v-if or a v-else-if element. Controlling Reusable Elements with keyVue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types: &lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; Then switching the loginType in the code above will not erase what the user has already entered. Since both templates use the same elements, the &lt;input&gt; is not replaced - just its placeholder. Check it out for yourself by entering some text in the input, then pressing the toggle button: Username Email Toggle login type new Vue({ el: '#no-key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } }) This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate - don’t re-use them.” Just add a key attribute with unique values: &lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; Now those inputs will be rendered from scratch each time you toggle. See for yourself: Username Email Toggle login type new Vue({ el: '#key-example', data: { loginType: 'username' }, methods: { toggleLoginType: function () { return this.loginType = this.loginType === 'username' ? 'email' : 'username' } } }) Note that the &lt;label&gt; elements are still efficiently re-used, because they don’t have key attributes. v-showAnother option for conditionally displaying an element is the v-show directive. The usage is largely the same: &lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; The difference is that an element with v-show will always be rendered and remain in the DOM; v-show simply toggles the display CSS property of the element. Note that v-show doesn’t support the &lt;template&gt; syntax, nor does it work with v-else. v-if vs v-showv-if is “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles. v-if is also lazy: if the condition is false on initial render, it will not do anything - the conditional block won’t be rendered until the condition becomes true for the first time. In comparison, v-show is much simpler - the element is always rendered regardless of initial condition, with just simple CSS-based toggling. Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime. v-if with v-forWhen used together with v-if, v-for has a higher priority than v-if. See the list rendering guide for details."},{"title":"Custom Directives","date":"2017-07-23T06:47:55.854Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/custom-directive.html","permalink":"https://rohmikwon.github.io/v2/guide/custom-directive.html","excerpt":"","text":"IntroIn addition to the default set of directives shipped in core (v-model and v-show), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you just need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one: Vue.directive('focus', { inserted: function (el) { el.focus() } }) new Vue({ el: '#simplest-directive-example' }) When the page loads, that element gains focus (note: autofocus doesn’t work on mobile Safari). In fact, if you haven’t clicked on anything else since visiting this page, the input above should be focused now. Now let’s build the directive that accomplishes this: // Register a global custom directive called v-focusVue.directive('focus', &#123; // When the bound element is inserted into the DOM... inserted: function (el) &#123; // Focus the element el.focus() &#125;&#125;) If you want to register a directive locally instead, components also accept a directives option: directives: &#123; focus: &#123; // directive definition &#125;&#125; Then in a template, you can use the new v-focus attribute on any element, like this: &lt;input v-focus&gt; Hook FunctionsA directive definition object can provide several hook functions (all optional): bind: called only once, when the directive is first bound to the element. This is where you can do one-time setup work. inserted: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document). update: called after the containing component has updated, but possibly before its children have updated. The directive’s value may or may not have changed, but you can skip unnecessary updates by comparing the binding’s current and old values (see below on hook arguments). componentUpdated: called after the containing component and its children have updated. unbind: called only once, when the directive is unbound from the element. We’ll explore the arguments passed into these hooks (i.e. el, binding, vnode, and oldVnode) in the next section. Directive Hook ArgumentsDirective hooks are passed these arguments: el: The element the directive is bound to. This can be used to directly manipulate the DOM. binding: An object containing the following properties. name: The name of the directive, without the v- prefix. value: The value passed to the directive. For example in v-my-directive=&quot;1 + 1&quot;, the value would be 2. oldValue: The previous value, only available in update and componentUpdated. It is available whether or not the value has changed. expression: The expression of the binding as a string. For example in v-my-directive=&quot;1 + 1&quot;, the expression would be &quot;1 + 1&quot;. arg: The argument passed to the directive, if any. For example in v-my-directive:foo, the arg would be &quot;foo&quot;. modifiers: An object containing modifiers, if any. For example in v-my-directive.foo.bar, the modifiers object would be { foo: true, bar: true }. vnode: The virtual node produced by Vue’s compiler. See the VNode API for full details. oldVnode: The previous virtual node, only available in the update and componentUpdated hooks. Apart from el, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element’s dataset. An example of a custom directive using some of these properties: &lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt; Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;) Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) new Vue({ el: '#hook-arguments-example', data: { message: 'hello!' } }) Function ShorthandIn many cases, you may want the same behavior on bind and update, but don’t care about the other hooks. For example: Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) Object LiteralsIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression. &lt;div v-demo=\"&#123; color: 'white', text: 'hello!' &#125;\"&gt;&lt;/div&gt; Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"&#125;)"},{"title":"Production Deployment Tips","date":"2017-07-23T06:47:55.855Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/deployment.html","permalink":"https://rohmikwon.github.io/v2/guide/deployment.html","excerpt":"","text":"Turn on Production ModeDuring development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app’s payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode. Without Build ToolsIf you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (vue.min.js) for production. Both versions can be found in the Installation guide. With Build ToolsWhen using a build tool like Webpack or Browserify, the production mode will be determined by process.env.NODE_ENV inside Vue’s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue’s production mode, and warnings will be stripped by minifiers during the build. All vue-cli templates have these pre-configured for you, but it would be beneficial to know how it is done: WebpackUse Webpack’s DefinePlugin to indicate a production environment, so that warning blocks can be automatically dropped by UglifyJS during minification. Example config: var webpack = require('webpack')module.exports = &#123; // ... plugins: [ // ... new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: '\"production\"' &#125; &#125;) ]&#125; Browserify Run your bundling command with the actual NODE_ENV environment variable set to &quot;production&quot;. This tells vueify to avoid including hot-reload and development related code. Apply a global envify transform to your bundle. This allows the minifier to strip out all the warnings in Vue’s source code wrapped in env variable conditional blocks. For example: NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js RollupUse rollup-plugin-replace: const replace = require('rollup-plugin-replace')rollup(&#123; // ... plugins: [ replace(&#123; 'process.env.NODE_ENV': JSON.stringify( 'production' ) &#125;) ]&#125;).then(...) Pre-Compiling TemplatesWhen using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive. The easiest way to pre-compile templates is using Single-File Components - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings. If you are using Webpack, and prefer separating JavaScript and template files, you can use vue-template-loader, which also transforms the template files into JavaScript render functions during the build step. Extracting Component CSSWhen using Single-File Components, the CSS inside components are injected dynamically as &lt;style&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a “flash of unstyled content”. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching. Refer to the respective build tool documentations to see how it’s done: Webpack + vue-loader (the vue-cli webpack template has this pre-configured) Browserify + vueify Rollup + rollup-plugin-vue Tracking Runtime ErrorsIf a runtime error occurs during a component’s render, it will be passed to the global Vue.config.errorHandler config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like Sentry, which provides an official integration for Vue."},{"title":"Event Handling","date":"2017-07-23T06:47:55.855Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/events.html","permalink":"https://rohmikwon.github.io/v2/guide/events.html","excerpt":"","text":"Listening to EventsWe can use the v-on directive to listen to DOM events and run some JavaScript when they’re triggered. For example: &lt;div id=\"example-1\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;Add 1&lt;/button&gt; &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;&lt;/div&gt; var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) Result: Add 1 The button above has been clicked {{ counter }} times. var example1 = new Vue({ el: '#example-1', data: { counter: 0 } }) Method Event HandlersThe logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the v-on attribute simply isn’t feasible. That’s why v-on can also accept the name of a method you’d like to call. For example: &lt;div id=\"example-2\"&gt; &lt;!-- `greet` is the name of a method defined below --&gt; &lt;button v-on:click=\"greet\"&gt;Greet&lt;/button&gt;&lt;/div&gt; var example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // define methods under the `methods` object methods: &#123; greet: function (event) &#123; // `this` inside methods points to the Vue instance alert('Hello ' + this.name + '!') // `event` is the native DOM event if (event) &#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// you can invoke methods in JavaScript tooexample2.greet() // -&gt; 'Hello Vue.js!' Result: Greet var example2 = new Vue({ el: '#example-2', data: { name: 'Vue.js' }, methods: { greet: function (event) { alert('Hello ' + this.name + '!') if (event) { alert(event.target.tagName) } } } }) Methods in Inline HandlersInstead of binding directly to a method name, we can also use methods in an inline JavaScript statement: &lt;div id=\"example-3\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt; new Vue(&#123; el: '#example-3', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;) Result: Say hi Say what new Vue({ el: '#example-3', methods: { say: function (message) { alert(message) } } }) Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special $event variable: &lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt; // ...methods: &#123; warn: function (message, event) &#123; // now we have access to the native event if (event) event.preventDefault() alert(message) &#125;&#125; Event ModifiersIt is a very common need to call event.preventDefault() or event.stopPropagation() inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details. To address this problem, Vue provides event modifiers for v-on. Recall that modifiers are directive postfixes denoted by a dot. .stop .prevent .capture .self .once &lt;!-- the click event's propagation will be stopped --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- the submit event will no longer reload the page --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- modifiers can be chained --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- just the modifier --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- use capture mode when adding the event listener --&gt;&lt;!-- i.e. an event targeting an inner element is handled here before being handled by that element --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- only trigger handler if event.target is the element itself --&gt;&lt;!-- i.e. not from a child element --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; Order matters when using modifiers because the relevant code is generated in the same order. Therefore using @click.prevent.self will prevent all clicks while @click.self.prevent will only prevent clicks on the element itself. New in 2.1.4+ &lt;!-- the click event will be triggered at most once --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; Unlike the other modifiers, which are exclusive to native DOM events, the .once modifier can also be used on component events. If you haven’t read about components yet, don’t worry about this for now. Key ModifiersWhen listening for keyboard events, we often need to check for common key codes. Vue also allows adding key modifiers for v-on when listening for key events: &lt;!-- only call vm.submit() when the keyCode is 13 --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; Remembering all the keyCodes is a hassle, so Vue provides aliases for the most commonly used keys: &lt;!-- same as above --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- also works for shorthand --&gt;&lt;input @keyup.enter=\"submit\"&gt; Here’s the full list of key modifier aliases: .enter .tab .delete (captures both “Delete” and “Backspace” keys) .esc .space .up .down .left .right You can also define custom key modifier aliases via the global config.keyCodes object: // enable v-on:keyup.f1Vue.config.keyCodes.f1 = 112 Modifier Keys New in 2.1.0 You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed: .ctrl .alt .shift .meta Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”. For example: &lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; Note that modifier keys are different from regular keys and when used with keyup events, they have to be pressed when the event is emitted. In other words, keyup.ctrl will only trigger if you release a key while holding down ctrl. It won’t trigger if you release the ctrl key alone. Mouse Button Modifiers New in 2.2.0+ .left .right .middle These modifiers restrict the handler to events triggered by a specific mouse button. Why Listeners in HTML?You might be concerned that this whole event listening approach violates the good old rules about “separation of concerns”. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that’s handling the current view, it won’t cause any maintenance difficulty. In fact, there are several benefits in using v-on: It’s easier to locate the handler function implementations within your JS code by simply skimming the HTML template. Since you don’t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test. When a ViewModel is destroyed, all event listeners are automatically removed. You don’t need to worry about cleaning it up yourself."},{"title":"Form Input Bindings","date":"2017-07-23T06:47:55.856Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/forms.html","permalink":"https://rohmikwon.github.io/v2/guide/forms.html","excerpt":"","text":"Basic UsageYou can use the v-model directive to create two-way data bindings on form input and textarea elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, v-model is essentially syntax sugar for updating data on user input events, plus special care for some edge cases. v-model will ignore the initial value, checked or selected attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the data option of your component. For languages that require an IME (Chinese, Japanese, Korean etc.), you’ll notice that v-model doesn’t get updated during IME composition. If you want to cater for these updates as well, use input event instead. Text&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; Message is: {{ message }} new Vue({ el: '#example-1', data: { message: '' } }) Multiline text&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=\"white-space: pre-line\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=\"message\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt; Multiline message is: {{ message }} new Vue({ el: '#example-textarea', data: { message: '' } }) Interpolation on textareas (&lt;textarea&gt;{{text}}&lt;/textarea&gt;) won't work. Use v-model instead. CheckboxSingle checkbox, boolean value: &lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; {{ checked }} new Vue({ el: '#example-2', data: { checked: false } }) Multiple checkboxes, bound to the same Array: &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;&lt;label for=\"jack\"&gt;Jack&lt;/label&gt;&lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;&lt;label for=\"john\"&gt;John&lt;/label&gt;&lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;&lt;label for=\"mike\"&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt; new Vue(&#123; el: '...', data: &#123; checkedNames: [] &#125;&#125;) Jack John Mike Checked names: {{ checkedNames }} new Vue({ el: '#example-3', data: { checkedNames: [] } }) Radio&lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt;&lt;label for=\"one\"&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt;&lt;label for=\"two\"&gt;Two&lt;/label&gt;&lt;br&gt;&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt; One Two Picked: {{ picked }} new Vue({ el: '#example-4', data: { picked: '' } }) SelectSingle select: &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;Please select one&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; new Vue(&#123; el: '...', data: &#123; selected: '' &#125;&#125;) Please select one A B C Selected: {{ selected }} new Vue({ el: '#example-5', data: { selected: '' } }) If the initial value of your v-model expression does not match any of the options, the &lt;select&gt; element will render in an “unselected” state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above. Multiple select (bound to Array): &lt;select v-model=\"selected\" multiple&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;br&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; A B C Selected: {{ selected }} new Vue({ el: '#example-6', data: { selected: [] } }) Dynamic options rendered with v-for: &lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; new Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;) {{ option.text }} Selected: {{ selected }} new Vue({ el: '#example-7', data: { selected: 'A', options: [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ] } }) Value BindingsFor radio, checkbox and select options, the v-model binding values are usually static strings (or booleans for checkbox): &lt;!-- `picked` is a string \"a\" when checked --&gt;&lt;input type=\"radio\" v-model=\"picked\" value=\"a\"&gt;&lt;!-- `toggle` is either true or false --&gt;&lt;input type=\"checkbox\" v-model=\"toggle\"&gt;&lt;!-- `selected` is a string \"abc\" when selected --&gt;&lt;select v-model=\"selected\"&gt; &lt;option value=\"abc\"&gt;ABC&lt;/option&gt;&lt;/select&gt; But sometimes we may want to bind the value to a dynamic property on the Vue instance. We can use v-bind to achieve that. In addition, using v-bind allows us to bind the input value to non-string values. Checkbox&lt;input type=\"checkbox\" v-model=\"toggle\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"&gt; // when checked:vm.toggle === vm.a// when unchecked:vm.toggle === vm.b Radio&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt; // when checked:vm.pick === vm.a Select Options&lt;select v-model=\"selected\"&gt; &lt;!-- inline object literal --&gt; &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt; // when selected:typeof vm.selected // -&gt; 'object'vm.selected.number // -&gt; 123 Modifiers.lazyBy default, v-model syncs the input with the data after each input event (with the exception of IME composition as stated above). You can add the lazy modifier to instead sync after change events: &lt;!-- synced after \"change\" instead of \"input\" --&gt;&lt;input v-model.lazy=\"msg\" &gt; .numberIf you want user input to be automatically typecast as a number, you can add the number modifier to your v-model managed inputs: &lt;input v-model.number=\"age\" type=\"number\"&gt; This is often useful, because even with type=&quot;number&quot;, the value of HTML input elements always returns a string. .trimIf you want user input to be trimmed automatically, you can add the trim modifier to your v-model managed inputs: &lt;input v-model.trim=\"msg\"&gt; v-model with Components If you’re not yet familiar with Vue’s components, just skip this for now. HTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with v-model! To learn more, read about custom inputs in the Components guide."},{"title":"Introduction","date":"2017-07-23T06:47:55.856Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/index.html","permalink":"https://rohmikwon.github.io/v2/guide/index.html","excerpt":"","text":"What is Vue.js?Vue (pronounced /vjuː/, like view) is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is very easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries. If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the Comparison with Other Frameworks. Getting StartedThe official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required. The easiest way to try out Vue.js is using the JSFiddle Hello World example. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can simply create an index.html file and include Vue with: &lt;script src=\"https://unpkg.com/vue\"&gt;&lt;/script&gt; The Installation page provides more options of installing Vue. Note that we do not recommend beginners to start with vue-cli, especially if you are not yet familiar with Node.js-based build tools. Declarative RenderingAt the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward template syntax: &lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;&#125;) {{ message }} var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }) We have already created our very first Vue app! This looks pretty similar to just rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now reactive. How do we know? Just open your browser’s JavaScript console (right now, on this page) and set app.message to a different value. You should see the rendered example above update accordingly. In addition to text interpolation, we can also bind element attributes like this: &lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\"&gt; Hover your mouse over me for a few seconds to see my dynamically bound title! &lt;/span&gt;&lt;/div&gt; var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: 'You loaded this page on ' + new Date() &#125;&#125;) Hover your mouse over me for a few seconds to see my dynamically bound title! var app2 = new Vue({ el: '#app-2', data: { message: 'You loaded this page on ' + new Date() } }) Here we are encountering something new. The v-bind attribute you are seeing is called a directive. Directives are prefixed with v- to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here it is basically saying “keep this element’s title attribute up-to-date with the message property on the Vue instance.” If you open up your JavaScript console again and enter app2.message = &#39;some new message&#39;, you’ll once again see that the bound HTML - in this case the title attribute - has been updated. Conditionals and LoopsIt’s quite simple to toggle the presence of an element, too: &lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;Now you see me&lt;/p&gt;&lt;/div&gt; var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) Now you see me var app3 = new Vue({ el: '#app-3', data: { seen: true } }) Go ahead and enter app3.seen = false in the console. You should see the message disappear. This example demonstrates that we can bind data to not only text and attributes, but also the structure of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply transition effects when elements are inserted/updated/removed by Vue. There are quite a few other directives, each with its own special functionality. For example, the v-for directive can be used for displaying a list of items using the data from an Array: &lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: 'Learn JavaScript' &#125;, &#123; text: 'Learn Vue' &#125;, &#123; text: 'Build something awesome' &#125; ] &#125;&#125;) {{ todo.text }} var app4 = new Vue({ el: '#app-4', data: { todos: [ { text: 'Learn JavaScript' }, { text: 'Learn Vue' }, { text: 'Build something awesome' } ] } }) In the console, enter app4.todos.push({ text: &#39;New item&#39; }). You should see a new item appended to the list. Handling User InputTo let users interact with your app, we can use the v-on directive to attach event listeners that invoke methods on our Vue instances: &lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt;Reverse Message&lt;/button&gt;&lt;/div&gt; var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: 'Hello Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) {{ message }} Reverse Message var app5 = new Vue({ el: '#app-5', data: { message: 'Hello Vue.js!' }, methods: { reverseMessage: function () { this.message = this.message.split('').reverse().join('') } } }) Note in the method we simply update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic. Vue also provides the v-model directive that makes two-way binding between form input and app state a breeze: &lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;) {{ message }} var app6 = new Vue({ el: '#app-6', data: { message: 'Hello Vue!' } }) Composing with ComponentsThe component system is another important concept in Vue, because it’s an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components: In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward: // Define a new component called todo-itemVue.component('todo-item', &#123; template: '&lt;li&gt;This is a todo&lt;/li&gt;'&#125;) Now you can compose it in another component’s template: &lt;ol&gt; &lt;!-- Create an instance of the todo-item component --&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; But this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let’s modify the component definition to make it accept a prop: Vue.component('todo-item', &#123; // The todo-item component now accepts a // \"prop\", which is like a custom attribute. // This prop is called todo. props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;) Now we can pass the todo into each repeated component using v-bind: &lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;!-- Now we provide each todo-item with the todo object it's representing, so that its content can be dynamic. We also need to provide each component with a \"key\", which will be explained later. --&gt; &lt;todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\"&gt; &lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; id: 0, text: 'Vegetables' &#125;, &#123; id: 1, text: 'Cheese' &#125;, &#123; id: 2, text: 'Whatever else humans are supposed to eat' &#125; ] &#125;&#125;) Vue.component('todo-item', { props: ['todo'], template: '{{ todo.text }}' }) var app7 = new Vue({ el: '#app-7', data: { groceryList: [ { id: 0, text: 'Vegetables' }, { id: 1, text: 'Cheese' }, { id: 2, text: 'Whatever else humans are supposed to eat' } ] } }) This is just a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;todo-item&gt; component with more complex template and logic without affecting the parent app. In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components later in the guide, but here’s an (imaginary) example of what an app’s template might look like with components: &lt;div id=\"app\"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; Relation to Custom ElementsYou may have noticed that Vue components are very similar to Custom Elements, which are part of the Web Components Spec. That’s because Vue’s component syntax is loosely modeled after the spec. For example, Vue components implement the Slot API and the is special attribute. However, there are a few key differences: The Web Components Spec is still in draft status, and is not natively implemented in every browser. In comparison, Vue components don’t require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element. Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations. Ready for More?We’ve just briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!"},{"title":"Installation","date":"2017-07-23T06:47:55.857Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/installation.html","permalink":"https://rohmikwon.github.io/v2/guide/installation.html","excerpt":"","text":"Compatibility NoteVue does not support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all ECMAScript 5 compliant browsers. Release NotesDetailed release notes for each version are available on GitHub. Direct &lt;script&gt; IncludeSimply download and include with a script tag. Vue will be registered as a global variable. Don’t use the minified version during development. You will miss out on all the nice warnings for common mistakes! Development VersionWith full warnings and debug modeProduction VersionWarnings stripped, 28.96kb min+gzip CDNRecommended: https://unpkg.com/vue, which will reflect the latest version as soon as it is published to npm. You can also browse the source of the npm package at https://unpkg.com/vue/. Also available on jsDelivr or cdnjs, but these two services take some time to sync so the latest release may not be available yet. NPMNPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as Webpack or Browserify. Vue also provides accompanying tools for authoring Single File Components. # latest stable$ npm install vue CLIVue.js provides an official CLI for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds: # install vue-cli$ npm install --global vue-cli# create a new project using the \"webpack\" template$ vue init webpack my-project# install dependencies and go!$ cd my-project$ npm install$ npm run dev The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through the guide without any build tools before using the CLI. Explanation of Different BuildsIn the dist/ directory of the NPM package you will find many different builds of Vue.js. Here’s an overview of the difference between them: UMD CommonJS ES Module Full vue.js vue.common.js vue.esm.js Runtime-only vue.runtime.js vue.runtime.common.js vue.runtime.esm.js Full (production) vue.min.js - - Runtime-only (production) vue.runtime.min.js - - Terms Full: builds that contains both the compiler and the runtime. Compiler: code that is responsible for compiling template strings into JavaScript render functions. Runtime: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler. UMD: UMD builds can be used directly in the browser via a &lt;script&gt; tag. The default file from Unpkg CDN at https://unpkg.com/vue is the Runtime + Compiler UMD build (vue.js). CommonJS: CommonJS builds are intended for use with older bundlers like browserify or webpack 1. The default file for these bundlers (pkg.main) is the Runtime only CommonJS build (vue.runtime.common.js). ES Module: ES module builds are intended for use with modern bundlers like webpack 2 or rollup. The default file for these bundlers (pkg.module) is the Runtime only ES Module build (vue.runtime.esm.js). Runtime + Compiler vs. Runtime-onlyIf you need to compile templates on the fly (e.g. passing a string to the template option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build: // this requires the compilernew Vue(&#123; template: '&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'&#125;)// this does notnew Vue(&#123; render (h) &#123; return h('div', this.hi) &#125;&#125;) When using vue-loader or vueify, templates inside *.vue files are pre-compiled into JavaScript at build time. You don’t really need the compiler in the final bundle, and can therefore use the runtime-only build. Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler: Webpackmodule.exports = &#123; // ... resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1 &#125; &#125;&#125; Rollupconst alias = require('rollup-plugin-alias')rollup(&#123; // ... plugins: [ alias(&#123; 'vue': 'vue/dist/vue.esm.js' &#125;) ]&#125;) BrowserifyAdd to your project’s package.json: &#123; // ... \"browser\": &#123; \"vue\": \"vue/dist/vue.common.js\" &#125;&#125; Development vs. Production ModeDevelopment/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production. CommonJS and ES Module builds are intended for bundlers, therefore we don’t provide minified versions for them. You will be responsible for minifying the final bundle yourself. CommonJS and ES Module builds also preserve raw checks for process.env.NODE_ENV to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing process.env.NODE_ENV with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size. WebpackUse Webpack’s DefinePlugin: var webpack = require('webpack')module.exports = &#123; // ... plugins: [ // ... new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;) ]&#125; RollupUse rollup-plugin-replace: const replace = require('rollup-plugin-replace')rollup(&#123; // ... plugins: [ replace(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;) ]&#125;).then(...) BrowserifyApply a global envify transform to your bundle. NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js Also see Production Deployment Tips. CSP environmentsSome environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of new Function() for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments. On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with Webpack + vue-loader or Browserify + vueify, your templates will be precompiled into render functions which work perfectly in CSP environments. Dev BuildImportant: the built files in GitHub’s /dist folder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself! git clone https://github.com/vuejs/vue.git node_modules/vuecd node_modules/vuenpm installnpm run build BowerOnly UMD builds are available from Bower. # latest stable$ bower install vue AMD Module LoadersAll UMD builds can be used directly as an AMD module."},{"title":"The Vue Instance","date":"2017-07-23T06:47:55.858Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/instance.html","permalink":"https://rohmikwon.github.io/v2/guide/instance.html","excerpt":"","text":"ConstructorEvery Vue application is bootstrapped by creating a root Vue instance with the Vue constructor function: var vm = new Vue(&#123; // options&#125;) Although not strictly associated with the MVVM pattern, Vue’s design was partly inspired by it. As a convention, we often use the variable vm (short for ViewModel) to refer to our Vue instance. When you instantiate a Vue instance, you need to pass in an options object which can contain options for data, template, element to mount on, methods, lifecycle callbacks, and more. The full list of options can be found in the API reference. The Vue constructor can be extended to create reusable component constructors with pre-defined options: var MyComponent = Vue.extend(&#123; // extension options&#125;)// all instances of `MyComponent` are created with// the pre-defined extension optionsvar myComponentInstance = new MyComponent() Although it is possible to create extended instances imperatively, most of the time it is recommended to compose them declaratively in templates as custom elements. We will talk about the component system in detail later. For now, you just need to know that all Vue components are essentially extended Vue instances. Properties and MethodsEach Vue instance proxies all the properties found in its data object: var data = &#123; a: 1 &#125;var vm = new Vue(&#123; data: data&#125;)vm.a === data.a // -&gt; true// setting the property also affects original datavm.a = 2data.a // -&gt; 2// ... and vice-versadata.a = 3vm.a // -&gt; 3 It should be noted that only these proxied properties are reactive, meaning any changes to their values will trigger the view to re-render. If you attach a new property to the instance after it has been created, it will not trigger any view updates. We will discuss the reactivity system in detail later. In addition to data properties, Vue instances expose a number of useful instance properties and methods. These properties and methods are prefixed with $ to differentiate them from proxied data properties. For example: var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById('example') // -&gt; true// $watch is an instance methodvm.$watch('a', function (newVal, oldVal) &#123; // this callback will be called when `vm.a` changes&#125;) Don’t use arrow functions on an instance property or callback (e.g. vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())). As arrow functions are bound to the parent context, this will not be the Vue instance as you’d expect and this.myMethod will be undefined. Consult the API reference for the full list of instance properties and methods. Instance Lifecycle HooksEach Vue instance goes through a series of initialization steps when it is created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it will also invoke some lifecycle hooks, which give us the opportunity to execute custom logic. For example, the created hook is called after the instance is created: var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function () &#123; // `this` points to the vm instance console.log('a is: ' + this.a) &#125;&#125;)// -&gt; \"a is: 1\" There are also other hooks which will be called at different stages of the instance’s lifecycle, for example mounted, updated, and destroyed. All lifecycle hooks are called with their this context pointing to the Vue instance invoking it. You may have been wondering where the concept of “controllers” lives in the Vue world and the answer is: there are no controllers. Your custom logic for a component would be split among these lifecycle hooks. Lifecycle DiagramBelow is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but this diagram will be helpful in the future."},{"title":"Computed Properties and Watchers","date":"2017-07-23T06:47:55.853Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/computed.html","permalink":"https://rohmikwon.github.io/v2/guide/computed.html","excerpt":"","text":"Computed PropertiesIn-template expressions are very convenient, but they are really only meant for simple operations. Putting too much logic into your templates can make them bloated and hard to maintain. For example: &lt;div id=\"example\"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays message in reverse. The problem is made worse when you want to include the reversed message in your template more than once. That’s why for any complex logic, you should use a computed property. Basic Example&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split('').reverse().join('') &#125; &#125;&#125;) Result: Original message: \"{{ message }}\" Computed reversed message: \"{{ reversedMessage }}\" var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } } }) Here we have declared a computed property reversedMessage. The function we provided will be used as the getter function for the property vm.reversedMessage: console.log(vm.reversedMessage) // -&gt; 'olleH'vm.message = 'Goodbye'console.log(vm.reversedMessage) // -&gt; 'eybdooG' You can open the console and play with the example vm yourself. The value of vm.reversedMessage is always dependent on the value of vm.message. You can data-bind to computed properties in templates just like a normal property. Vue is aware that vm.reversedMessage depends on vm.message, so it will update any bindings that depend on vm.reversedMessage when vm.message changes. And the best part is that we’ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easy to test and reason about. Computed Caching vs MethodsYou may have noticed we can achieve the same result by invoking a method in the expression: &lt;p&gt;Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"&lt;/p&gt; // in componentmethods: &#123; reverseMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; Instead of a computed property, we can define the same function as a method instead. For the end result, the two approaches are indeed exactly the same. However, the difference is that computed properties are cached based on their dependencies. A computed property will only re-evaluate when some of its dependencies have changed. This means as long as message has not changed, multiple access to the reversedMessage computed property will immediately return the previously computed result without having to run the function again. This also means the following computed property will never update, because Date.now() is not a reactive dependency: computed: &#123; now: function () &#123; return Date.now() &#125;&#125; In comparison, a method invocation will always run the function whenever a re-render happens. Why do we need caching? Imagine we have an expensive computed property A, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on A. Without caching, we would be executing A’s getter many more times than necessary! In cases where you do not want caching, use a method instead. Computed vs Watched PropertyVue does provide a more generic way to observe and react to data changes on a Vue instance: watch properties. When you have some data that needs to change based on some other data, it is tempting to overuse watch - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative watch callback. Consider this example: &lt;div id=\"demo\"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) The above code is imperative and repetitive. Compare it with a computed property version: var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) Much better, isn’t it? Computed SetterComputed properties are by default getter-only, but you can also provide a setter when you need it: // ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ... Now when you run vm.fullName = &#39;John Doe&#39;, the setter will be invoked and vm.firstName and vm.lastName will be updated accordingly. WatchersWhile computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That’s why Vue provides a more generic way to react to data changes through the watch option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data. For example: &lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;!-- Since there is already a rich ecosystem of ajax libraries --&gt;&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;&lt;!-- is able to remain small by not reinventing them. This also --&gt;&lt;!-- gives you the freedom to just use what you're familiar with. --&gt;&lt;script src=\"https://unpkg.com/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // whenever question changes, this function will run question: function (newQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce is a function provided by lodash to limit how // often a particularly expensive operation can be run. // In this case, we want to limit how often we access // yesno.wtf/api, waiting until the user has completely // finished typing before making the ajax request. To learn // more about the _.debounce function (and its cousin // _.throttle), visit: https://lodash.com/docs#debounce getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // This is the number of milliseconds we wait for the // user to stop typing. 500 ) &#125;&#125;)&lt;/script&gt; Result: Ask a yes/no question: {{ answer }} var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { question: function (newQuestion) { this.answer = 'Waiting for you to stop typing...' this.getAnswer() } }, methods: { getAnswer: _.debounce( function () { var vm = this if (this.question.indexOf('?') === -1) { vm.answer = 'Questions usually contain a question mark. ;-)' return } vm.answer = 'Thinking...' axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) }, 500 ) } }) In this case, using the watch option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property. In addition to the watch option, you can also use the imperative vm.$watch API."},{"title":"Join the Vue.js Community!","date":"2017-07-23T06:47:55.858Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/join.html","permalink":"https://rohmikwon.github.io/v2/guide/join.html","excerpt":"","text":"Vue’s community is growing incredibly fast and if you’re reading this, there’s a good chance you’re ready to join it. So… welcome! Now we’ll answer both what the community can do for you and what you can do for the community. Resources You’ll EnjoyGet Support Forum: The best place to ask questions and get answers about Vue and its ecosystem. Chat: A place for Vue devs to meet and chat in real time. Github: If you have a bug to report or feature to request, that’s what the GitHub issues are for. We also welcome pull requests! Explore the Ecosystem The Awesome Vue Page: See what other awesome resources have been published by other awesome people. The “Show and Tell” Subforum: Another great place to check out what others have built with and for the growing Vue ecosystem. What You Can DoContribute CodeAs with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read the contributing guide. After that, you’ll be ready to contribute to Vue’s core repositories: vue: the core library vuex: Flux-inspired state management vue-router: a routing system for SPAs …as well as many smaller official companion libraries. Share (and Build) Your ExperienceApart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know: Develop learning materials. It’s often said that the best way to learn is to teach. If there’s something interesting you’re doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even just publishing a gist that you share on social media. Watch a repo you care about. This will send you notifications whenever there’s activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It’s a fantastic way to build expertise so that you’re eventually able to help address issues and pull requests. Translate DocsVue has already spread across the globe, with even the core team in at least half a dozen timezones. The forum includes 7 languages and counting and many of our docs have actively-maintained translations. We’re very proud of Vue’s international reach, but we can do even better. I hope that right now, you’re reading this sentence in your preferred language. If not, would you like to help us get there? If so, please feel free to fork the repo for these docs or for any other officially maintained documentation, then start translating. Once you’ve made some progress, open an issue or pull request in the main repo and we’ll put out a call for more contributors to help you out."},{"title":"List Rendering","date":"2017-07-23T06:47:55.859Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/list.html","permalink":"https://rohmikwon.github.io/v2/guide/list.html","excerpt":"","text":"v-forWe can use the v-for directive to render a list of items based on an array. The v-for directive requires a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on: Basic Usage&lt;ul id=\"example-1\"&gt; &lt;li v-for=\"item in items\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) Result: {{item.message}} var example1 = new Vue({ el: '#example-1', data: { items: [ { message: 'Foo' }, { message: 'Bar' } ] }, watch: { items: function () { smoothScroll.animateScroll(document.querySelector('#example-1')) } } }) Inside v-for blocks we have full access to parent scope properties. v-for also supports an optional second argument for the index of the current item. &lt;ul id=\"example-2\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; var example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) Result: {{ parentMessage }} - {{ index }} - {{ item.message }} var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [ { message: 'Foo' }, { message: 'Bar' } ] }, watch: { items: function () { smoothScroll.animateScroll(document.querySelector('#example-2')) } } }) You can also use of as the delimiter instead of in, so that it is closer to JavaScript’s syntax for iterators: &lt;div v-for=\"item of items\"&gt;&lt;/div&gt; Template v-forSimilar to template v-if, you can also use a &lt;template&gt; tag with v-for to render a block of multiple elements. For example: &lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; Object v-forYou can also use v-for to iterate through the properties of an object. &lt;ul id=\"repeat-object\" class=\"demo\"&gt; &lt;li v-for=\"value in object\"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; new Vue(&#123; el: '#repeat-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;) Result: {{ value }} new Vue({ el: '#repeat-object', data: { object: { firstName: 'John', lastName: 'Doe', age: 30 } } }) You can also provide a second argument for the key: &lt;div v-for=\"(value, key) in object\"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; And another for the index: &lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; When iterating over an object, the order is based on the key enumeration order of Object.keys(), which is not guaranteed to be consistent across JavaScript engine implementations. Range v-forv-for can also take an integer. In this case it will repeat the template that many times. &lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; Result: {{ n }} new Vue({ el: '#range' }) Components and v-for This section assumes knowledge of Components. Feel free to skip it and come back later. You can directly use v-for on a custom component, like any normal element: &lt;my-component v-for=\"item in items\" :key=\"item.id\"&gt;&lt;/my-component&gt; In 2.2.0+, when using v-for with a component, a key is now required. However, this won’t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props: &lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\"&gt;&lt;/my-component&gt; The reason for not automatically injecting item into the component is because that makes the component tightly coupled to how v-for works. Being explicit about where its data comes from makes the component reusable in other situations. Here’s a complete example of a simple todo list: &lt;div id=\"todo-list-example\"&gt; &lt;input v-model=\"newTodoText\" v-on:keyup.enter=\"addNewTodo\" placeholder=\"Add a todo\" &gt; &lt;ul&gt; &lt;li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"index\" v-bind:title=\"todo\" v-on:remove=\"todos.splice(index, 1)\" &gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; Vue.component('todo-item', &#123; template: '\\ &lt;li&gt;\\ &#123;&#123; title &#125;&#125;\\ &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;X&lt;/button&gt;\\ &lt;/li&gt;\\ ', props: ['title']&#125;)new Vue(&#123; el: '#todo-list-example', data: &#123; newTodoText: '', todos: [ 'Do the dishes', 'Take out the trash', 'Mow the lawn' ] &#125;, methods: &#123; addNewTodo: function () &#123; this.todos.push(this.newTodoText) this.newTodoText = '' &#125; &#125;&#125;) Vue.component('todo-item', { template: '\\ \\ {{ title }}\\ X\\ \\ ', props: ['title'] }) new Vue({ el: '#todo-list-example', data: { newTodoText: '', todos: [ 'Do the dishes', 'Take out the trash', 'Mow the lawn' ] }, methods: { addNewTodo: function () { this.todos.push(this.newTodoText) this.newTodoText = '' } } }) v-for with v-ifWhen they exist on the same node, v-for has a higher priority than v-if. That means the v-if will be run on each iteration of the loop separately. This is very useful when you want to render nodes for only some items, like below: &lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; The above only renders the todos that are not complete. If instead, your intent is to conditionally skip execution of the loop, you can place the v-if on a wrapper element (or &lt;template&gt;). For example: &lt;ul v-if=\"shouldRenderTodos\"&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt; keyWhen Vue is updating a list of elements rendered with v-for, it by default uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will simply patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of track-by=&quot;$index&quot; in Vue 1.x. This default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values). To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique key attribute for each item. An ideal value for key would be the unique id of each item. This special attribute is a rough equivalent to track-by in 1.x, but it works like an attribute, so you need to use v-bind to bind it to dynamic values (using shorthand here): &lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- content --&gt;&lt;/div&gt; It is recommended to provide a key with v-for whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains. Since it’s a generic mechanism for Vue to identify nodes, the key also has other uses that are not specifically tied to v-for, as we will see later in the guide. Array Change DetectionMutation MethodsVue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are: push() pop() shift() unshift() splice() sort() reverse() You can open the console and play with the previous examples’ items array by calling their mutation methods. For example: example1.items.push({ message: &#39;Baz&#39; }). Replacing an ArrayMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. filter(), concat() and slice(), which do not mutate the original array but always return a new array. When working with non-mutating methods, you can just replace the old array with the new one: example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation. CaveatsDue to limitations in JavaScript, Vue cannot detect the following changes to an array: When you directly set an item with the index, e.g. vm.items[indexOfItem] = newValue When you modify the length of the array, e.g. vm.items.length = newLength To overcome caveat 1, both of the following will accomplish the same as vm.items[indexOfItem] = newValue, but will also trigger state updates in the reactivity system: // Vue.setVue.set(example1.items, indexOfItem, newValue) // Array.prototype.spliceexample1.items.splice(indexOfItem, 1, newValue) To deal with caveat 2, you can use splice: example1.items.splice(newLength) Displaying Filtered/Sorted ResultsSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array. For example: &lt;li v-for=\"n in evenNumbers\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; In situations where computed properties are not feasible (e.g. inside nested v-for loops), you can just use a method: &lt;li v-for=\"n in even(numbers)\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125;"},{"title":"Migration from Vue Router 0.7.x","date":"2017-07-23T06:47:55.859Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/migration-vue-router.html","permalink":"https://rohmikwon.github.io/v2/guide/migration-vue-router.html","excerpt":"","text":"Only Vue Router 2 is compatible with Vue 2, so if you’re updating Vue, you’ll have to update Vue Router as well. That’s why we’ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the Vue Router docs. Router Initializationrouter.start replacedThere is no longer a special API to initialize an app with Vue Router. That means instead of: router.start(&#123; template: '&lt;router-view&gt;&lt;/router-view&gt;'&#125;, '#app') You’ll just pass a router property to a Vue instance: new Vue(&#123; el: '#app', router: router, template: '&lt;router-view&gt;&lt;/router-view&gt;'&#125;) Or, if you’re using the runtime-only build of Vue: new Vue(&#123; el: '#app', router: router, render: h =&gt; h('router-view')&#125;) Upgrade Path Run the migration helper on your codebase to find examples of router.start being called. Route Definitionsrouter.map replacedRoutes are now defined as an array on a routes option at router instantiation. So these routes for example: router.map(&#123; '/foo': &#123; component: Foo &#125;, '/bar': &#123; component: Bar &#125;&#125;) Will instead be defined with: var router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125; ]&#125;) The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same key order across browsers. Upgrade Path Run the migration helper on your codebase to find examples of router.map being called. router.on removedIf you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example: // Normal base routesvar routes = [ // ...]// Dynamically generated routesmarketingPages.forEach(function (page) &#123; routes.push(&#123; path: '/marketing/' + page.slug component: &#123; extends: MarketingComponent data: function () &#123; return &#123; page: page &#125; &#125; &#125; &#125;)&#125;)var router = new Router(&#123; routes: routes&#125;) If you need to add new routes after the router has been instantiated, you can replace the router’s matcher with a new one that includes the route you’d like to add: router.match = createMatcher( [&#123; path: '/my/new/path', component: MyComponent &#125;].concat(router.options.routes)) Upgrade Path Run the migration helper on your codebase to find examples of router.on being called. subRoutes renamedRenamed to children for consistency within Vue and with other routing libraries. Upgrade Path Run the migration helper on your codebase to find examples of the subRoutes option. router.redirect replacedThis is now an option on route definitions. So for example, you will update: router.redirect(&#123; '/tos': '/terms-of-service'&#125;) to a definition like below in your routes configuration: &#123; path: '/tos', redirect: '/terms-of-service'&#125; Upgrade Path Run the migration helper on your codebase to find examples of router.redirect being called. router.alias replacedThis is now an option on the definition for the route you’d like to alias to. So for example, you will update: router.alias(&#123; '/manage': '/admin'&#125;) to a definition like below in your routes configuration: &#123; path: '/admin', component: AdminPanel, alias: '/manage'&#125; If you need multiple aliases, you can also use an array syntax: alias: ['/manage', '/administer', '/administrate'] Upgrade Path Run the migration helper on your codebase to find examples of router.alias being called. Arbitrary Route Properties replacedArbitrary route properties must now be scoped under the new meta property, to avoid conflicts with future features. So for example, if you had defined: '/admin': &#123; component: AdminPanel, requiresAuth: true&#125; Then you would now update it to: &#123; path: '/admin', component: AdminPanel, meta: &#123; requiresAuth: true &#125;&#125; Then when later accessing this property on a route, you will still go through meta. For example: if (route.meta.requiresAuth) &#123; // ...&#125; Upgrade Path Run the migration helper on your codebase to find examples of arbitrary route properties not scoped under meta. [] Syntax for Arrays in Queries removedWhen passing arrays to query parameters the QueryString syntax is no longer /foo?users[]=Tom&amp;users[]=Jerry, instead, the new syntax is /foo?users=Tom&amp;users=Jerry. Internally, $route.query.users will still be an Array, but if there’s only one parameter in the query: /foo?users=Tom, when directly accessing this route, there’s no way for the router to know if we were expecting users to be an Array. Because of this, consider adding a computed property and replacing every reference of $route.query.users with it: export default &#123; // ... computed: &#123; // users will always be an array users () &#123; const users = this.$route.query.users return Array.isArray(users) ? users : [users] &#125; &#125;&#125; Route MatchingRoute matching now uses path-to-regexp under the hood, making it much more flexible than previously. One or More Named Parameters changedThe syntax has changed slightly, so /category/*tags for example, should be updated to /category/:tags+. Upgrade Path Run the migration helper on your codebase to find examples of the obsolete route syntax. Linksv-link replacedThe v-link directive has been replaced with a new &lt;router-link&gt; component, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this: &lt;a v-link=\"'/about'\"&gt;About&lt;/a&gt; You’ll need to update it like this: &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; Note that target=&quot;_blank&quot; is not supported on &lt;router-link&gt;, so if you need to open a link in a new tab, you have to use &lt;a&gt; instead. Upgrade Path Run the migration helper on your codebase to find examples of the v-link directive. v-link-active replacedThe v-link-active directive has also been replaced by the tag attribute on the &lt;router-link&gt; component. So for example, you’ll update this: &lt;li v-link-active&gt; &lt;a v-link=\"'/about'\"&gt;About&lt;/a&gt;&lt;/li&gt; to this: &lt;router-link tag=\"li\" to=\"/about\"&gt; &lt;a&gt;About&lt;/a&gt;&lt;/router-link&gt; The &lt;a&gt; will be the actual link (and will get the correct href), but the active class will be applied to the outer &lt;li&gt;. Upgrade Path Run the migration helper on your codebase to find examples of the v-link-active directive. Programmatic Navigationrouter.go changedFor consistency with the HTML5 History API, router.go is now only used for back/forward navigation, while router.push is used to navigate to a specific page. Upgrade Path Run the migration helper on your codebase to find examples of router.go being used where router.push should be used instead. Router Options: Modeshashbang: false removedHashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy. Upgrade Path Run the migration helper on your codebase to find examples of the hashbang: false option. history: true replacedAll routing mode options have been condensed into a single mode option. Update: var router = new VueRouter(&#123; history: 'true'&#125;) to: var router = new VueRouter(&#123; mode: 'history'&#125;) Upgrade Path Run the migration helper on your codebase to find examples of the history: true option. abstract: true replacedAll routing mode options have been condensed into a single mode option. Update: var router = new VueRouter(&#123; abstract: 'true'&#125;) to: var router = new VueRouter(&#123; mode: 'abstract'&#125;) Upgrade Path Run the migration helper on your codebase to find examples of the abstract: true option. Route Options: MiscsaveScrollPosition replacedThis has been replaced with a scrollBehavior option that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to simply replicate the old behavior of: saveScrollPosition: true You can replace it with: scrollBehavior: function (to, from, savedPosition) &#123; return savedPosition || &#123; x: 0, y: 0 &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of the saveScrollPosition: true option. root renamedRenamed to base for consistency with the HTML &lt;base&gt; element. Upgrade Path Run the migration helper on your codebase to find examples of the root option. transitionOnLoad removedThis option is no longer necessary now that Vue’s transition system has explicit appear transition control. Upgrade Path Run the migration helper on your codebase to find examples of the transitionOnLoad: true option. suppressTransitionError removedRemoved due to hooks simplification. If you really must suppress transition errors, you can use try…catch instead. Upgrade Path Run the migration helper on your codebase to find examples of the suppressTransitionError: true option. Route Hooksactivate replacedUse beforeRouteEnter in the component instead. Upgrade Path Run the migration helper on your codebase to find examples of the beforeRouteEnter hook. canActivate replacedUse beforeEnter in the route instead. Upgrade Path Run the migration helper on your codebase to find examples of the canActivate hook. deactivate removedUse the component’s beforeDestroy or destroyed hooks instead. Upgrade Path Run the migration helper on your codebase to find examples of the deactivate hook. canDeactivate replacedUse beforeRouteLeave in the component instead. Upgrade Path Run the migration helper on your codebase to find examples of the canDeactivate hook. canReuse: false removedThere’s no longer a use case for this in the new Vue Router. Upgrade Path Run the migration helper on your codebase to find examples of the canReuse: false option. data replacedThe $route property is now reactive, so you can just use a watcher to react to route changes, like this: watch: &#123; '$route': 'fetchData'&#125;,methods: &#123; fetchData: function () &#123; // ... &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of the data hook. $loadingRouteData removedDefine your own property (e.g. isLoading), then update the loading state in a watcher on the route. For example, if fetching data with axios: data: function () &#123; return &#123; posts: [], isLoading: false, fetchError: null &#125;&#125;,watch: &#123; '$route': function () &#123; var self = this self.isLoading = true self.fetchData().then(function () &#123; self.isLoading = false &#125;) &#125;&#125;,methods: &#123; fetchData: function () &#123; var self = this return axios.get('/api/posts') .then(function (response) &#123; self.posts = response.data.posts &#125;) .catch(function (error) &#123; self.fetchError = error &#125;) &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of the $loadingRouteData meta property."},{"title":"Migration from Vuex 0.6.x to 1.0","date":"2017-07-23T06:47:55.860Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/migration-vuex.html","permalink":"https://rohmikwon.github.io/v2/guide/migration-vuex.html","excerpt":"","text":"Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What’s going on? Which one should I use and what’s compatible with Vue 2.0? Both Vuex 1.0 and 2.0: fully support both Vue 1.0 and 2.0 will be maintained for the foreseeable future They have slightly different target users however. Vuex 2.0 is a radical redesign and simplification of the API, for those who are starting new projects or want to be on the cutting edge of client-side state management. It is not covered by this migration guide, so you should check out the Vuex 2.0 docs if you’d like to learn more about it. Vuex 1.0 is mostly backwards-compatible, so requires very few changes to upgrade. It is recommended for those with large existing codebases or who just want the smoothest possible upgrade path to Vue 2.0. This guide is dedicated to facilitating that process, but only includes migration notes. For the complete usage guide, see the Vuex 1.0 docs. store.watch with String Property Path replacedstore.watch now only accept functions. So for example, you would have to replace: store.watch('user.notifications', callback) with: store.watch( // When the returned result changes... function (state) &#123; return state.user.notifications &#125;, // Run this callback callback) This gives you more complete control over the reactive properties you’d like to watch. Upgrade Path Run the migration helper on your codebase to find examples of store.watch with a string as the first argument. Store’s Event Emitter removedThe store instance no longer exposes the event emitter interface (on, off, emit). If you were previously using the store as a global event bus, see this section for migration instructions. Instead of using this interface to watch events emitted by the store itself (e.g. store.on(&#39;mutation&#39;, callback)), a new method store.subscribe is introduced. Typical usage inside a plugin would be: var myPlugin = store =&gt; &#123; store.subscribe(function (mutation, state) &#123; // Do something... &#125;)&#125; See example the plugins docs for more info. Upgrade Path Run the migration helper on your codebase to find examples of store.on, store.off, and store.emit. Middlewares replacedMiddlewares are replaced by plugins. A plugin is simply a function that receives the store as the only argument, and can listen to the mutation event on the store: const myPlugins = store =&gt; &#123; store.subscribe('mutation', (mutation, state) =&gt; &#123; // Do something... &#125;)&#125; For more details, see the plugins docs. Upgrade Path Run the migration helper on your codebase to find examples of the middlewares option on a store."},{"title":"Mixins","date":"2017-07-23T06:47:55.861Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/mixins.html","permalink":"https://rohmikwon.github.io/v2/guide/mixins.html","excerpt":"","text":"BasicsMixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own options. Example: // define a mixin objectvar myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// define a component that uses this mixinvar Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // -&gt; \"hello from mixin!\" Option MergingWhen a mixin and the component itself contain overlapping options, they will be “merged” using appropriate strategies. For example, hook functions with the same name are merged into an array so that all of them will be called. In addition, mixin hooks will be called before the component’s own hooks: var mixin = &#123; created: function () &#123; console.log('mixin hook called') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('component hook called') &#125;&#125;)// -&gt; \"mixin hook called\"// -&gt; \"component hook called\" Options that expect object values, for example methods, components and directives, will be merged into the same object. The component’s options will take priority when there are conflicting keys in these objects: var mixin = &#123; methods: &#123; foo: function () &#123; console.log('foo') &#125;, conflicting: function () &#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log('bar') &#125;, conflicting: function () &#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // -&gt; \"foo\"vm.bar() // -&gt; \"bar\"vm.conflicting() // -&gt; \"from self\" Note that the same merge strategies are used in Vue.extend(). Global MixinYou can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect every Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options: // inject a handler for `myOption` custom optionVue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// -&gt; \"hello!\" Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It’s also a good idea to ship them as Plugins to avoid duplicate application. Custom Option Merge StrategiesWhen custom options are merged, they use the default strategy, which simply overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to Vue.config.optionMergeStrategies: Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) &#123; // return mergedVal&#125; For most object-based options, you can simply use the same strategy used by methods: var strategies = Vue.config.optionMergeStrategiesstrategies.myOption = strategies.methods A more advanced example can be found on Vuex‘s 1.x merging strategy: const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) &#123; if (!toVal) return fromVal if (!fromVal) return toVal return &#123; getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) &#125;&#125;"},{"title":"Plugins","date":"2017-07-23T06:47:55.862Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/plugins.html","permalink":"https://rohmikwon.github.io/v2/guide/plugins.html","excerpt":"","text":"Writing a PluginPlugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins you can write: Add some global methods or properties. e.g. vue-custom-element Add one or more global assets: directives/filters/transitions etc. e.g. vue-touch Add some component options by global mixin. e.g. vuex Add some Vue instance methods by attaching them to Vue.prototype. A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. vue-router A Vue.js plugin should expose an install method. The method will be called with the Vue constructor as the first argument, along with possible options: MyPlugin.install = function (Vue, options) &#123; // 1. add global method or property Vue.myGlobalMethod = function () &#123; // something logic ... &#125; // 2. add a global asset Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // something logic ... &#125; ... &#125;) // 3. inject some component options Vue.mixin(&#123; created: function () &#123; // something logic ... &#125; ... &#125;) // 4. add an instance method Vue.prototype.$myMethod = function (methodOptions) &#123; // something logic ... &#125;&#125; Using a PluginUse plugins by calling the Vue.use() global method: // calls `MyPlugin.install(Vue)`Vue.use(MyPlugin) You can optionally pass in some options: Vue.use(MyPlugin, &#123; someOption: true &#125;) Vue.use automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once. Some plugins provided by Vue.js official plugins such as vue-router automatically calls Vue.use() if Vue is available as a global variable. However in a module environment such as CommonJS, you always need to call Vue.use() explicitly: // When using CommonJS via Browserify or Webpackvar Vue = require('vue')var VueRouter = require('vue-router')// Don't forget to call thisVue.use(VueRouter) Checkout awesome-vue for a huge collection of community-contributed plugins and libraries."},{"title":"Migration from Vue 1.x","date":"2017-07-23T06:47:55.861Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/migration.html","permalink":"https://rohmikwon.github.io/v2/guide/migration.html","excerpt":"","text":"FAQ Woah - this is a super long page! Does that mean 2.0 is completely different, I’ll have to learn the basics all over again, and migrating will be practically impossible? I’m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven’t changed. It’s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, this is not something you have to read from top to bottom! Where should I start in a migration? Start by running the migration helper on a current project. We’ve carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they’ll let you know, offer suggestions, and provide links to more info. After that, browse through the table of contents for this page in the sidebar. If you see a topic you may be affected by, but the migration helper didn’t catch, check it out. If you have any tests, run them and see what still fails. If you don’t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around. By now, your app should be fully migrated. If you’re still hungry for more though, you can read the rest of this page - or just dive in to the new and improved guide from the beginning. Many parts will be skimmable, since you’re already familiar with the core concepts. How long will it take to migrate a Vue 1.x app to 2.0? It depends on a few factors: The size of your app (small to medium-sized apps will probably be less than a day) How many times you get distracted and start playing with a cool new feature. 😉 &nbsp;Not judging, it also happened to us while building 2.0! Which obsolete features you’re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you’re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor. If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue-Router? Only Vue-Router 2 is compatible with Vue 2, so yes, you’ll have to follow the migration path for Vue-Router as well. Fortunately, most applications don’t have a lot of router code, so this likely won’t take more than an hour. As for Vuex, even version 0.8 is compatible with Vue 2, so you’re not forced to upgrade. The only reason you may want to upgrade immediately is to take advantage of the new features in Vuex 2, such as modules and reduced boilerplate. TemplatesFragment Instances removedEvery component must have exactly one root element. Fragment instances are no longer allowed. If you have a template like this: &lt;p&gt;foo&lt;/p&gt;&lt;p&gt;bar&lt;/p&gt; It’s recommended to simply wrap the entire contents in a new element, like this: &lt;div&gt; &lt;p&gt;foo&lt;/p&gt; &lt;p&gt;bar&lt;/p&gt;&lt;/div&gt; Upgrade Path Run your end-to-end test suite or app after upgrading and look for console warnings about multiple root elements in a template. Lifecycle HooksbeforeCompile removedUse the created hook instead. Upgrade Path Run the migration helper on your codebase to find all examples of this hook. compiled replacedUse the new mounted hook instead. Upgrade Path Run the migration helper on your codebase to find all examples of this hook. attached removedUse a custom in-DOM check in other hooks. For example, to replace: attached: function () &#123; doSomething()&#125; You could use: mounted: function () &#123; this.$nextTick(function () &#123; doSomething() &#125;)&#125; Upgrade Path Run the migration helper on your codebase to find all examples of this hook. detached removedUse a custom in-DOM check in other hooks. For example, to replace: detached: function () &#123; doSomething()&#125; You could use: destroyed: function () &#123; this.$nextTick(function () &#123; doSomething() &#125;)&#125; Upgrade Path Run the migration helper on your codebase to find all examples of this hook. init renamedUse the new beforeCreate hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods. Upgrade Path Run the migration helper on your codebase to find all examples of this hook. ready replacedUse the new mounted hook instead. It should be noted though that with mounted, there’s no guarantee to be in-document. For that, also include Vue.nextTick/vm.$nextTick. For example: mounted: function () &#123; this.$nextTick(function () &#123; // code that assumes this.$el is in-document &#125;)&#125; Upgrade Path Run the migration helper on your codebase to find all examples of this hook. v-forv-for Argument Order for Arrays changedWhen including an index, the argument order for arrays used to be (index, value). It is now (value, index) to be more consistent with JavaScript’s native array methods such as forEach and map. Upgrade Path Run the migration helper on your codebase to find examples of the obsolete argument order. Note that if you name your index arguments something unusual like position or num, the helper will not flag them. v-for Argument Order for Objects changedWhen including a key, the argument order for objects used to be (key, value). It is now (value, key) to be more consistent with common object iterators such as lodash’s. Upgrade Path Run the migration helper on your codebase to find examples of the obsolete argument order. Note that if you name your key arguments something like name or property, the helper will not flag them. $index and $key removedThe implicitly assigned $index and $key variables have been removed in favor of explicitly defining them in v-for. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops. Upgrade Path Run the migration helper on your codebase to find examples of these removed variables. If you miss any, you should also see console errors such as: Uncaught ReferenceError: $index is not defined track-by replacedtrack-by has been replaced with key, which works like any other attribute: without the v-bind: or : prefix, it is treated as a literal string. In most cases, you’d want to use a dynamic binding which expects a full expression instead of a key. For example, in place of: &lt;div v-for=\"item in items\" track-by=\"id\"&gt; You would now write: &lt;div v-for=\"item in items\" v-bind:key=\"item.id\"&gt; Upgrade Path Run the migration helper on your codebase to find examples of track-by. v-for Range Values changedPreviously, v-for=&quot;number in 10&quot; would have number starting at 0 and ending at 9. Now it starts at 1 and ends at 10. Upgrade Path Search your codebase for the regex /\\w+ in \\d+/. Wherever it appears in a v-for, check to see if you may be affected. Propscoerce Prop Option removedIf you want to coerce a prop, setup a local computed value based on it instead. For example, instead of: props: &#123; username: &#123; type: String, coerce: function (value) &#123; return value .toLowerCase() .replace(/\\s+/, '-') &#125; &#125;&#125; You could write: props: &#123; username: String,&#125;,computed: &#123; normalizedUsername: function () &#123; return this.username .toLowerCase() .replace(/\\s+/, '-') &#125;&#125; There are a few advantages: You still have access to the original value of the prop. You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop. Upgrade Path Run the migration helper on your codebase to find examples of the coerce option. twoWay Prop Option removedProps are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see: Custom component events Custom input components (using component events) Global state management Upgrade Path Run the migration helper on your codebase to find examples of the twoWay option. .once and .sync Modifiers on v-bind removedProps are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see: Custom component events Custom input components (using component events) Global state management Upgrade Path Run the migration helper on your codebase to find examples of the .once and .sync modifiers. Prop Mutation deprecatedMutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting this.myProp = &#39;someOtherValue&#39; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component’s local changes will be overwritten. Most use cases of mutating a prop can be replaced by one of these options: a data property, with the prop used to set its default value a computed property Upgrade Path Run your end-to-end test suite or app after upgrading and look for console warnings about prop mutations. Props on a Root Instance replacedOn root Vue instances (i.e. instances created with new Vue({ ... })), you must use propsData instead of props. Upgrade Path Run your end-to-end test suite, if you have one. The failed tests should alert to you to the fact that props passed to root instances are no longer working. Computed propertiescache: false deprecatedCaching invalidation of computed properties will be removed in future major versions of Vue. Replace any uncached computed properties with methods, which will have the same result. For example: template: '&lt;p&gt;message: &#123;&#123; timeMessage &#125;&#125;&lt;/p&gt;',computed: &#123; timeMessage: &#123; cache: false, get: function () &#123; return Date.now() + this.message &#125; &#125;&#125; Or with component methods: template: '&lt;p&gt;message: &#123;&#123; getTimeMessage &#125;&#125;&lt;/p&gt;',methods: &#123; getTimeMessage: function () &#123; return Date.now() + this.message &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of the cache: false option. Built-In DirectivesTruthiness/Falsiness with v-bind changedWhen used with v-bind, the only falsy values are now: null, undefined, and false. This means 0 and empty strings will render as truthy. So for example, v-bind:draggable=&quot;&#39;&#39;&quot; will render as draggable=&quot;true&quot;. For enumerated attributes, in addition to the falsy values above, the string &quot;false&quot; will also render as attr=&quot;false&quot;. Note that for other directives (e.g. v-if and v-show), JavaScript’s normal truthiness still applies. Upgrade Path Run your end-to-end test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change. Listening for Native Events on Components with v-on changedWhen used on a component, v-on now only listens to custom events $emitted by that component. To listen for a native DOM event on the root element, you can use the .native modifier. For example: &lt;my-component v-on:click.native=\"doSomething\"&gt;&lt;/my-component&gt; Upgrade Path Run your end-to-end test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change. debounce Param Attribute for v-model removedDebouncing is used to limit how often we execute Ajax requests and other expensive operations. Vue’s debounce attribute parameter for v-model made this easy for very simple cases, but it actually debounced state updates rather than the expensive operations themselves. It’s a subtle difference, but it comes with limitations as an application grows. These limitations become apparent when designing a search indicator, like this one for example: {{ searchIndicator }} new Vue({ el: '#debounce-search-demo', data: { searchQuery: '', searchQueryIsDirty: false, isCalculating: false }, computed: { searchIndicator: function () { if (this.isCalculating) { return '⟳ Fetching new results' } else if (this.searchQueryIsDirty) { return '... Typing' } else { return '✓ Done' } } }, watch: { searchQuery: function () { this.searchQueryIsDirty = true this.expensiveOperation() } }, methods: { expensiveOperation: _.debounce(function () { this.isCalculating = true setTimeout(function () { this.isCalculating = false this.searchQueryIsDirty = false }.bind(this), 1000) }, 500) } }) Using the debounce attribute, there’d be no way to detect the “Typing” state, because we lose access to the input’s real-time state. By decoupling the debounce function from Vue however, we’re able to debounce only the operation we want to limit, removing the limits on features we can develop: &lt;!--By using the debounce function from lodash or another dedicatedutility library, we know the specific debounce implementation weuse will be best-in-class - and we can use it ANYWHERE. Not justin our template.--&gt;&lt;script src=\"https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js\"&gt;&lt;/script&gt;&lt;div id=\"debounce-search-demo\"&gt; &lt;input v-model=\"searchQuery\" placeholder=\"Type something\"&gt; &lt;strong&gt;&#123;&#123; searchIndicator &#125;&#125;&lt;/strong&gt;&lt;/div&gt; new Vue(&#123; el: '#debounce-search-demo', data: &#123; searchQuery: '', searchQueryIsDirty: false, isCalculating: false &#125;, computed: &#123; searchIndicator: function () &#123; if (this.isCalculating) &#123; return '⟳ Fetching new results' &#125; else if (this.searchQueryIsDirty) &#123; return '... Typing' &#125; else &#123; return '✓ Done' &#125; &#125; &#125;, watch: &#123; searchQuery: function () &#123; this.searchQueryIsDirty = true this.expensiveOperation() &#125; &#125;, methods: &#123; // This is where the debounce actually belongs. expensiveOperation: _.debounce(function () &#123; this.isCalculating = true setTimeout(function () &#123; this.isCalculating = false this.searchQueryIsDirty = false &#125;.bind(this), 1000) &#125;, 500) &#125;&#125;) Another advantage of this approach is there will be times when debouncing isn’t quite the right wrapper function. For example, when hitting an API for search suggestions, waiting to offer suggestions until after the user has stopped typing for a period of time isn’t an ideal experience. What you probably want instead is a throttling function. Now since you’re already using a utility library like lodash, refactoring to use its throttle function instead takes only a few seconds. Upgrade Path Run the migration helper on your codebase to find examples of the debounce attribute. lazy or number Param Attributes for v-model replacedThe lazy and number param attributes are now modifiers, to make it more clear what That means instead of: &lt;input v-model=\"name\" lazy&gt;&lt;input v-model=\"age\" type=\"number\" number&gt; You would use: &lt;input v-model.lazy=\"name\"&gt;&lt;input v-model.number=\"age\" type=\"number\"&gt; Upgrade Path Run the migration helper on your codebase to find examples of the these param attributes. value Attribute with v-model removedv-model no longer cares about the initial value of an inline value attribute. For predictability, it will instead always treat the Vue instance data as the source of truth. That means this element: &lt;input v-model=\"text\" value=\"foo\"&gt; backed by this data: data: &#123; text: 'bar'&#125; will render with a value of “bar” instead of “foo”. The same goes for a &lt;textarea&gt; with existing content. Instead of: &lt;textarea v-model=\"text\"&gt; hello world&lt;/textarea&gt; You should ensure your initial value for text is “hello world”. Upgrade Path Run your end-to-end test suite or app after upgrading and look for console warnings about inline value attributes with v-model. v-model with v-for Iterated Primitive Values removedCases like this no longer work: &lt;input v-for=\"str in strings\" v-model=\"str\"&gt; The reason is this is the equivalent JavaScript that the &lt;input&gt; would compile to: strings.map(function (str) &#123; return createElement('input', ...)&#125;) As you can see, v-model‘s two-way binding doesn’t make sense here. Setting str to another value in the iterator function will do nothing because it’s just a local variable in the function scope. Instead, you should use an array of objects so that v-model can update the field on the object. For example: &lt;input v-for=\"obj in objects\" v-model=\"obj.str\"&gt; Upgrade Path Run your test suite, if you have one. The failed tests should alert to you to any parts of your app that may be affected by this change. v-bind:style with Object Syntax and !important removedThis will no longer work: &lt;p v-bind:style=\"&#123; color: myColor + ' !important' &#125;\"&gt;hello&lt;/p&gt; If you really need to override another !important, you must use the string syntax: &lt;p v-bind:style=\"'color: ' + myColor + ' !important'\"&gt;hello&lt;/p&gt; Upgrade Path Run the migration helper on your codebase to find examples of style bindings with !important in objects. v-el and v-ref replacedFor simplicity, v-el and v-ref have been merged into the ref attribute, accessible on a component instance via $refs. That means v-el:my-element would become ref=&quot;myElement&quot; and v-ref:my-component would become ref=&quot;myComponent&quot;. When used on a normal element, the ref will be the DOM element, and when used on a component, the ref will be the component instance. Since v-ref is no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with v-for. For example: &lt;p v-for=\"item in items\" v-bind:ref=\"'item' + item.id\"&gt;&lt;/p&gt; Previously, v-el/v-ref combined with v-for would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by given each item the same ref: &lt;p v-for=\"item in items\" ref=\"items\"&gt;&lt;/p&gt; Unlike in 1.x, these $refs are not reactive, because they’re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change. On the other hand, $refs are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue’s data-driven view model. Upgrade Path Run the migration helper on your codebase to find examples of v-el and v-ref. v-else with v-show removedv-else no longer works with v-show. Use v-if with a negation expression instead. For example, instead of: &lt;p v-if=\"foo\"&gt;Foo&lt;/p&gt;&lt;p v-else v-show=\"bar\"&gt;Not foo, but bar&lt;/p&gt; You can use: &lt;p v-if=\"foo\"&gt;Foo&lt;/p&gt;&lt;p v-if=\"!foo &amp;&amp; bar\"&gt;Not foo, but bar&lt;/p&gt; Upgrade Path Run the migration helper on your codebase to find examples of the v-else with v-show. Custom Directives simplifiedDirectives have a greatly reduced scope of responsibility: they are now only used for applying low-level direct DOM manipulations. In most cases, you should prefer using components as the main code-reuse abstraction. Some of the most notable differences include: Directives no longer have instances. This means there’s no more this inside directive hooks. Instead, they receive everything they might need as arguments. If you really must persist state across hooks, you can do so on el. Options such as acceptStatement, deep, priority, etc have all been removed. To replace twoWay directives, see this example. Some of the current hooks have different behavior and there are also a couple new hooks. Fortunately, since the new directives are much simpler, you can master them more easily. Read the new Custom Directives guide to learn more. Upgrade Path Run the migration helper on your codebase to find examples of defined directives. The helper will flag all of them, as it's likely in most cases that you'll want to refactor to a component. Directive .literal Modifier removedThe .literal modifier has been removed, as the same can be easily achieved by just providing a string literal as the value. For example, you can update: &lt;p v-my-directive.literal=\"foo bar baz\"&gt;&lt;/p&gt; to just: &lt;p v-my-directive=\"'foo bar baz'\"&gt;&lt;/p&gt; Upgrade Path Run the migration helper on your codebase to find examples of the `.literal` modifier on a directive. Transitionstransition Attribute replacedVue’s transition system has changed quite drastically and now uses &lt;transition&gt; and &lt;transition-group&gt; wrapper elements, rather than the transition attribute. It’s recommended to read the new Transitions guide to learn more. Upgrade Path Run the migration helper on your codebase to find examples of the transition attribute. Vue.transition for Reusable Transitions replacedWith the new transition system, you can now just use components for reusable transitions. Upgrade Path Run the migration helper on your codebase to find examples of Vue.transition. Transition stagger Attribute removedIf you need to stagger list transitions, you can control timing by setting and accessing a data-index (or similar attribute) on an element. See an example here. Upgrade Path Run the migration helper on your codebase to find examples of the transition attribute. During your update, you can transition (pun very much intended) to the new staggering strategy as well. Eventsevents option removedThe events option has been removed. Event handlers should now be registered in the created hook instead. Check out the $dispatch and $broadcast migration guide for a detailed example. Vue.directive(&#39;on&#39;).keyCodes replacedThe new, more concise way to configure keyCodes is through Vue.config.keyCodes. For example: // enable v-on:keyup.f1Vue.config.keyCodes.f1 = 112 Upgrade Path Run the migration helper on your codebase to find examples of the the old keyCode configuration syntax. $dispatch and $broadcast replaced$dispatch and $broadcast have been removed in favor of more explicitly cross-component communication and more maintainable state management solutions, such as Vuex. The problem is event flows that depend on a component’s tree structure can be hard to reason about and very brittle when the tree becomes large. It simply doesn’t scale well and we don’t want to set you up for pain later. $dispatch and $broadcast also do not solve communication between sibling components. One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually listen to an $emit from a child with v-on. This allows you to keep the convenience of events with added explicitness. However, when communicating between distant descendants/ancestors, $emit won’t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose. For example, let’s say we have a todo app structured like this: Todos|-- NewTodoInput|-- Todo |-- DeleteTodoButton We could manage communication between components with this single event hub: // This is the event hub we'll use in every// component to communicate between them.var eventHub = new Vue() Then in our components, we can use $emit, $on, $off to emit events, listen for events, and clean up event listeners, respectively: // NewTodoInput// ...methods: &#123; addTodo: function () &#123; eventHub.$emit('add-todo', &#123; text: this.newTodoText &#125;) this.newTodoText = '' &#125;&#125; // DeleteTodoButton// ...methods: &#123; deleteTodo: function (id) &#123; eventHub.$emit('delete-todo', id) &#125;&#125; // Todos// ...created: function () &#123; eventHub.$on('add-todo', this.addTodo) eventHub.$on('delete-todo', this.deleteTodo)&#125;,// It's good to clean up event listeners before// a component is destroyed.beforeDestroy: function () &#123; eventHub.$off('add-todo', this.addTodo) eventHub.$off('delete-todo', this.deleteTodo)&#125;,methods: &#123; addTodo: function (newTodo) &#123; this.todos.push(newTodo) &#125;, deleteTodo: function (todoId) &#123; this.todos = this.todos.filter(function (todo) &#123; return todo.id !== todoId &#125;) &#125;&#125; This pattern can serve as a replacement for $dispatch and $broadcast in simple scenarios, but for more complex cases, it’s recommended to use a dedicated state management layer such as Vuex. Upgrade Path Run the migration helper on your codebase to find examples of $dispatch and $broadcast. FiltersFilters Outside Text Interpolations removedFilters can now only be used inside text interpolations ({{ }} tags). In the past we’ve found using filters within directives such as v-model, v-on, etc led to more complexity than convenience. For list filtering on v-for, it’s also better to move that logic into JavaScript as computed properties, so that it can be reused throughout your component. In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here’s how you can replace Vue’s built-in directive filters: Replacing the debounce FilterInstead of: &lt;input v-on:keyup=\"doStuff | debounce 500\"&gt; methods: &#123; doStuff: function () &#123; // ... &#125;&#125; Use lodash’s debounce (or possibly throttle) to directly limit calling the expensive method. You can achieve the same as above like this: &lt;input v-on:keyup=\"doStuff\"&gt; methods: &#123; doStuff: _.debounce(function () &#123; // ... &#125;, 500)&#125; For more on the advantages of this strategy, see the example here with v-model. Replacing the limitBy FilterInstead of: &lt;p v-for=\"item in items | limitBy 10\"&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; Use JavaScript’s built-in .slice method in a computed property: &lt;p v-for=\"item in filteredItems\"&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; computed: &#123; filteredItems: function () &#123; return this.items.slice(0, 10) &#125;&#125; Replacing the filterBy FilterInstead of: &lt;p v-for=\"user in users | filterBy searchQuery in 'name'\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; Use JavaScript’s built-in .filter method in a computed property: &lt;p v-for=\"user in filteredUsers\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; computed: &#123; filteredUsers: function () &#123; var self = this return self.users.filter(function (user) &#123; return user.name.indexOf(self.searchQuery) !== -1 &#125;) &#125;&#125; JavaScript’s native .filter can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email: var self = thisself.users.filter(function (user) &#123; var searchRegex = new RegExp(self.searchQuery, 'i') return user.isActive &amp;&amp; ( searchRegex.test(user.name) || searchRegex.test(user.email) )&#125;) Replacing the orderBy FilterInstead of: &lt;p v-for=\"user in users | orderBy 'name'\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; Use lodash’s orderBy (or possibly sortBy) in a computed property: &lt;p v-for=\"user in orderedUsers\"&gt;&#123;&#123; user.name &#125;&#125;&lt;/p&gt; computed: &#123; orderedUsers: function () &#123; return _.orderBy(this.users, 'name') &#125;&#125; You can even order by multiple columns: _.orderBy(this.users, ['name', 'last_login'], ['asc', 'desc']) Upgrade Path Run the migration helper on your codebase to find examples of filters being used inside directives. If you miss any, you should also see console errors. Filter Argument Syntax changedFilters’ syntax for arguments now better aligns with JavaScript function invocation. So instead of taking space-delimited arguments: &lt;p&gt;&#123;&#123; date | formatDate 'YY-MM-DD' timeZone &#125;&#125;&lt;/p&gt; We surround the arguments with parentheses and delimit the arguments with commas: &lt;p&gt;&#123;&#123; date | formatDate('YY-MM-DD', timeZone) &#125;&#125;&lt;/p&gt; Upgrade Path Run the migration helper on your codebase to find examples of the old filter syntax. If you miss any, you should also see console errors. Built-In Text Filters removedAlthough filters within text interpolations are still allowed, all of the filters have been removed. Instead, it’s recommended to use more specialized libraries for solving problems in each domain (e.g. date-fns to format dates and accounting for currencies). For each of Vue’s built-in text filters, we go through how you can replace them below. The example code could exist in custom helper functions, methods, or computed properties. Replacing the json FilterYou actually don’t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it’s a string, number, array, or plain object. If you want the exact same functionality as JavaScript’s JSON.stringify though, then you can use that in a method or computed property. Replacing the capitalize Filtertext[0].toUpperCase() + text.slice(1) Replacing the uppercase Filtertext.toUpperCase() Replacing the lowercase Filtertext.toLowerCase() Replacing the pluralize FilterThe pluralize package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like 0, then you can also easily define your own pluralize functions. For example: function pluralizeKnife (count) &#123; if (count === 0) &#123; return 'no knives' &#125; else if (count === 1) &#123; return '1 knife' &#125; else &#123; return count + 'knives' &#125;&#125; Replacing the currency FilterFor a very naive implementation, you could just do something like this: '$' + price.toFixed(2) In many cases though, you’ll still run into strange behavior (e.g. 0.035.toFixed(2) rounds up to 0.04, but 0.045 rounds down to 0.04). To work around these issues, you can use the accounting library to more reliably format currencies. Upgrade Path Run the migration helper on your codebase to find examples of the obsolete text filters. If you miss any, you should also see console errors. Two-Way Filters replacedSome users have enjoyed using two-way filters with v-model to create interesting inputs with very little code. While seemingly simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs. As an example, we’ll now walk the migration of a two-way currency filter: It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the Result tab and try entering 9.999 into one of those inputs. When the input loses focus, its value will update to $10.00. When looking at the calculated total however, you’ll see that 9.999 is what’s stored in our data. The version of reality that the user sees is out of sync! To start transitioning towards a more robust solution using Vue 2.0, let’s first wrap this filter in a new &lt;currency-input&gt; component: This allows us add behavior that a filter alone couldn’t encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external currencyValidator object: This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be: unit tested in isolation from your Vue code used by other parts of your application, such as to validate the payload to an API endpoint Having this validator extracted out, we’ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it’s actually impossible for users to enter anything wrong, similar to what the browser’s native number input tries to do. We’re still limited however, by filters and by Vue 1.0 in general, so let’s complete the upgrade to Vue 2.0: You may notice that: Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters. We can now use v-model directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly. Since we’re no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice. Upgrade Path Run the migration helper on your codebase to find examples of filters used in directives like v-model. If you miss any, you should also see console errors. SlotsDuplicate Slots removedIt is no longer supported to have &lt;slot&gt;s with the same name in the same template. When a slot is rendered it is “used up” and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop. Upgrade Path Run your end-to-end test suite or app after upgrading and look for console warnings about duplicate slots v-model. slot Attribute Styling removedContent inserted via named &lt;slot&gt; no longer preserves the slot attribute. Use a wrapper element to style them, or for advanced use cases, modify the inserted content programmatically using render functions. Upgrade Path Run the migration helper on your codebase to find CSS selectors targeting named slots (e.g. [slot=\"my-slot-name\"]). Special Attributeskeep-alive Attribute replacedkeep-alive is no longer a special attribute, but rather a wrapper component, similar to &lt;transition&gt;. For example: &lt;keep-alive&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; This makes it possible to use &lt;keep-alive&gt; on multiple conditional children: &lt;keep-alive&gt; &lt;todo-list v-if=\"todos.length &gt; 0\"&gt;&lt;/todo-list&gt; &lt;no-todos-gif v-else&gt;&lt;/no-todos-gif&gt;&lt;/keep-alive&gt; When &lt;keep-alive&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will simply be ignored. When used together with &lt;transition&gt;, make sure to nest it inside: &lt;transition&gt; &lt;keep-alive&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; Upgrade Path Run the migration helper on your codebase to find keep-alive attributes. InterpolationInterpolation within Attributes removedInterpolation within attributes is no longer valid. For example: &lt;button class=\"btn btn-&#123;&#123; size &#125;&#125;\"&gt;&lt;/button&gt; Should either be updated to use an inline expression: &lt;button v-bind:class=\"'btn btn-' + size\"&gt;&lt;/button&gt; Or a data/computed property: &lt;button v-bind:class=\"buttonClasses\"&gt;&lt;/button&gt; computed: &#123; buttonClasses: function () &#123; return 'btn btn-' + size &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of interpolation used within attributes. HTML Interpolation removedHTML interpolations ({{{ foo }}}) have been removed in favor of the v-html directive. Upgrade Path Run the migration helper on your codebase to find HTML interpolations. One-Time Bindings replacedOne time bindings ({{* foo }}) have been replaced by the new v-once directive. Upgrade Path Run the migration helper on your codebase to find one-time bindings. Reactivityvm.$watch changedWatchers created via vm.$watch are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component’s own data when the prop changes. If you were previously relying on vm.$watch to do something with the DOM after a component updates, you can instead do so in the updated lifecycle hook. Upgrade Path Run your end-to-end test suite, if you have one. The failed tests should alert to you to the fact that a watcher was relying on the old behavior. vm.$set changedvm.$set is now just an alias for Vue.set. Upgrade Path Run the migration helper on your codebase to find examples of the obsolete usage. vm.$delete changedvm.$delete is now just an alias for Vue.delete. Upgrade Path Run the migration helper on your codebase to find examples of the obsolete usage. Array.prototype.$set removedUse Vue.set instead. Upgrade Path Run the migration helper on your codebase to find examples of .$set on an array. If you miss any, you should see console errors from the missing method. Array.prototype.$remove removedUse Array.prototype.splice instead. For example: methods: &#123; removeTodo: function (todo) &#123; var index = this.todos.indexOf(todo) this.todos.splice(index, 1) &#125;&#125; Or better yet, just pass removal methods an index: methods: &#123; removeTodo: function (index) &#123; this.todos.splice(index, 1) &#125;&#125; Upgrade Path Run the migration helper on your codebase to find examples of .$remove on an array. If you miss any, you should see console errors from the missing method. Vue.set and Vue.delete on Vue instances removedVue.set and Vue.delete can no longer work on Vue instances. It is now mandatory to properly declare all top-level reactive properties in the data option. If you’d like to delete properties on a Vue instance or its $data, just set it to null. Upgrade Path Run the migration helper on your codebase to find examples of Vue.set or Vue.delete on a Vue instance. If you miss any, they'll trigger console warnings. Replacing vm.$data removedIt is now prohibited to replace a component instance’s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems). Upgrade Path Run the migration helper on your codebase to find examples of overwriting vm.$data. If you miss any, console warnings will be emitted. vm.$get removedJust retrieve reactive data directly. Upgrade Path Run the migration helper on your codebase to find examples of vm.$get. If you miss any, you'll see console errors. DOM-Focused Instance Methodsvm.$appendTo removedUse the native DOM API: myElement.appendChild(vm.$el) Upgrade Path Run the migration helper on your codebase to find examples of vm.$appendTo. If you miss any, you'll see console errors. vm.$before removedUse the native DOM API: myElement.parentNode.insertBefore(vm.$el, myElement) Upgrade Path Run the migration helper on your codebase to find examples of vm.$before. If you miss any, you'll see console errors. vm.$after removedUse the native DOM API: myElement.parentNode.insertBefore(vm.$el, myElement.nextSibling) Or if myElement is the last child: myElement.parentNode.appendChild(vm.$el) Upgrade Path Run the migration helper on your codebase to find examples of vm.$after. If you miss any, you'll see console errors. vm.$remove removedUse the native DOM API: vm.$el.remove() Upgrade Path Run the migration helper on your codebase to find examples of vm.$remove. If you miss any, you'll see console errors. Meta Instance Methodsvm.$eval removedNo real use. If you do happen to rely on this feature somehow and aren’t sure how to work around it, post on the forum for ideas. Upgrade Path Run the migration helper on your codebase to find examples of vm.$eval. If you miss any, you'll see console errors. vm.$interpolate removedNo real use. If you do happen to rely on this feature somehow and aren’t sure how to work around it, post on the forum for ideas. Upgrade Path Run the migration helper on your codebase to find examples of vm.$interpolate. If you miss any, you'll see console errors. vm.$log removedUse the Vue Devtools for the optimal debugging experience. Upgrade Path Run the migration helper on your codebase to find examples of vm.$log. If you miss any, you'll see console errors. Instance DOM Optionsreplace: false removedComponents now always replace the element they’re bound to. To simulate the behavior of replace: false, you can wrap your root component with an element similar to the one you’re replacing. For example: new Vue(&#123; el: '#app', template: '&lt;div id=\"app\"&gt; ... &lt;/div&gt;'&#125;) Or with a render function: new Vue(&#123; el: '#app', render: function (h) &#123; h('div', &#123; attrs: &#123; id: 'app', &#125; &#125;, /* ... */) &#125;&#125;) Upgrade Path Run the migration helper on your codebase to find examples of replace: false. Global ConfigVue.config.debug removedNo longer necessary, since warnings come with stack traces by default now. Upgrade Path Run the migration helper on your codebase to find examples of Vue.config.debug. Vue.config.async removedAsync is now required for rendering performance. Upgrade Path Run the migration helper on your codebase to find examples of Vue.config.async. Vue.config.delimiters replacedThis has been reworked as a component-level option. This allows you to use alternative delimiters within your app without breaking 3rd-party components. Upgrade Path Run the migration helper on your codebase to find examples of Vue.config.delimiters. Vue.config.unsafeDelimiters removedHTML interpolation has been removed in favor of v-html. Upgrade Path Run the migration helper on your codebase to find examples of Vue.config.unsafeDelimiters. After this, the helper will also find instances of HTML interpolation so that you can replace them with `v-html`. Global APIVue.extend with el removedThe el option can no longer be used in Vue.extend. It’s only valid as an instance creation option. Upgrade Path Run your end-to-end test suite or app after upgrading and look for console warnings about the el option with Vue.extend. Vue.elementDirective removedUse components instead. Upgrade Path Run the migration helper on your codebase to find examples of Vue.elementDirective. Vue.partial removedPartials have been removed in favor of more explicit data flow between components, using props. Unless you’re using a partial in a performance-critical area, the recommendation is to simply use a normal component instead. If you were dynamically binding the name of a partial, you can use a dynamic component. If you happen to be using partials in a performance-critical part of your app, then you should upgrade to functional components. They must be in a plain JS/JSX file (rather than in a .vue file) and are stateless and instanceless, just like partials. This makes rendering extremely fast. A benefit of functional components over partials is that they can be much more dynamic, because they grant you access to the full power of JavaScript. There is a cost to this power however. If you’ve never used a component framework with render functions before, they may take a bit longer to learn. Upgrade Path Run the migration helper on your codebase to find examples of Vue.partial."},{"title":"Reactivity in Depth","date":"2017-07-23T06:47:55.862Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/reactivity.html","permalink":"https://rohmikwon.github.io/v2/guide/reactivity.html","excerpt":"","text":"We’ve covered most of the basics - now it’s time to take a deep dive! One of Vue’s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management very simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system. How Changes Are TrackedWhen you pass a plain JavaScript object to a Vue instance as its data option, Vue will walk through all of its properties and convert them to getter/setters using Object.defineProperty. This is an ES5-only and un-shimmable feature, which is why Vue doesn’t support IE8 and below. The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install vue-devtools for a more inspection-friendly interface. Every component instance has a corresponding watcher instance, which records any properties “touched” during the component’s render as dependencies. Later on when a dependency’s setter is triggered, it notifies the watcher, which in turn causes the component to re-render. Change Detection CaveatsDue to the limitations of modern JavaScript (and the abandonment of Object.observe), Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the data object in order for Vue to convert it and make it reactive. For example: var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` is now reactivevm.b = 2// `vm.b` is NOT reactive Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it’s possible to add reactive properties to a nested object using the Vue.set(object, key, value) method: Vue.set(vm.someObject, 'b', 2) You can also use the vm.$set instance method, which is just an alias to the global Vue.set: this.$set(this.someObject, 'b', 2) Sometimes you may want to assign a number of properties to an existing object, for example using Object.assign() or _.extend(). However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object: // instead of `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) There are also a few array-related caveats, which were discussed earlier in the list rendering section. Declaring Reactive PropertiesSince Vue doesn’t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even just with an empty value: var vm = new Vue(&#123; data: &#123; // declare message with an empty value message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// set `message` latervm.message = 'Hello!' If you don’t declare message in the data option, Vue will warn you that the render function is trying to access a property that doesn’t exist. There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the data object is like the schema for your component’s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer. Async Update QueueIn case you haven’t noticed yet, Vue performs DOM updates asynchronously. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop “tick”, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native Promise.then and MutationObserver for the asynchronous queuing and falls back to setTimeout(fn, 0). For example, when you set vm.someData = &#39;new value&#39;, the component will not re-render immediately. It will update in the next “tick”, when the queue is flushed. Most of the time we don’t need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a “data-driven” fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use Vue.nextTick(callback) immediately after the data is changed. The callback will be called after the DOM has been updated. For example: &lt;div id=\"example\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; var vm = new Vue(&#123; el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // change datavm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) There is also the vm.$nextTick() instance method, which is especially handy inside components, because it doesn’t need global Vue and its callback’s this context will be automatically bound to the current Vue instance: Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: 'not updated' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; 'not updated' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; 'updated' &#125;) &#125; &#125;&#125;)"},{"title":"Render Functions","date":"2017-07-23T06:47:55.863Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/render-function.html","permalink":"https://rohmikwon.github.io/v2/guide/render-function.html","excerpt":"","text":"BasicsVue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That’s where you can use the render function, a closer-to-the-compiler alternative to templates. Let’s dive into a simple example where a render function would be practical. Say you want to generate anchored headings: &lt;h1&gt; &lt;a name=\"hello-world\" href=\"#hello-world\"&gt; Hello world! &lt;/a&gt;&lt;/h1&gt; For the HTML above, you decide you want this component interface: &lt;anchored-heading :level=\"1\"&gt;Hello world!&lt;/anchored-heading&gt; When you get started with a component that just generates a heading based on the level prop, you quickly arrive at this: &lt;script type=\"text/x-template\" id=\"anchored-heading-template\"&gt; &lt;h1 v-if=\"level === 1\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if=\"level === 2\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-else-if=\"level === 3\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-else-if=\"level === 4\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-else-if=\"level === 5\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-else-if=\"level === 6\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt;&lt;/script&gt; Vue.component('anchored-heading', &#123; template: '#anchored-heading-template', props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) That template doesn’t feel great. It’s not only verbose, but we’re duplicating &lt;slot&gt;&lt;/slot&gt; for every heading level and will have to do the same when we add the anchor element. While templates work great for most components, it’s clear that this isn’t one of them. So let’s try rewriting it with a render function: Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name this.$slots.default // array of children ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a slot attribute into a component, like the Hello world! inside of anchored-heading, those children are stored on the component instance at $slots.default. If you haven’t already, it’s recommended to read through the instance properties API before diving into render functions. createElement ArgumentsThe second thing you’ll have to become familiar with is how to use template features in the createElement function. Here are the arguments that createElement accepts: // @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // An HTML tag name, component options, or function // returning one of these. Required. 'div', // &#123;Object&#125; // A data object corresponding to the attributes // you would use in a template. Optional. &#123; // (see details in the next section below) &#125;, // &#123;String | Array&#125; // Children VNodes, built using `createElement()`, // or simply using strings to get 'text VNodes'. Optional. [ 'Some text comes first.', createElement('h1', 'A headline'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;) ]) The Data Object In-DepthOne thing to note: similar to how v-bind:class and v-bind:style have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as innerHTML (this would replace the v-html directive): &#123; // Same API as `v-bind:class` 'class': &#123; foo: true, bar: false &#125;, // Same API as `v-bind:style` style: &#123; color: 'red', fontSize: '14px' &#125;, // Normal HTML attributes attrs: &#123; id: 'foo' &#125;, // Component props props: &#123; myProp: 'bar' &#125;, // DOM properties domProps: &#123; innerHTML: 'baz' &#125;, // Event handlers are nested under `on`, though // modifiers such as in `v-on:keyup.enter` are not // supported. You'll have to manually check the // keyCode in the handler instead. on: &#123; click: this.clickHandler &#125;, // For components only. Allows you to listen to // native events, rather than events emitted from // the component using `vm.$emit`. nativeOn: &#123; click: this.nativeClickHandler &#125;, // Custom directives. Note that the binding's // oldValue cannot be set, as Vue keeps track // of it for you. directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // Scoped slots in the form of // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // The name of the slot, if this component is the // child of another component slot: 'name-of-slot', // Other special top-level properties key: 'myKey', ref: 'myRef'&#125; Complete ExampleWith this knowledge, we can now finish the component we started: var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join('')&#125;Vue.component('anchored-heading', &#123; render: function (createElement) &#123; // create kebabCase id var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^\\-|\\-$)/g, '') return createElement( 'h' + this.level, [ createElement('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) ConstraintsVNodes Must Be UniqueAll VNodes in the component tree must be unique. That means the following render function is invalid: render: function (createElement) &#123; var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // Yikes - duplicate VNodes! myParagraphVNode, myParagraphVNode ])&#125; If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs: render: function (createElement) &#123; return createElement('div', Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement('p', 'hi') &#125;) )&#125; Replacing Template Features with Plain JavaScriptv-if and v-forWherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using v-if and v-for: &lt;ul v-if=\"items.length\"&gt; &lt;li v-for=\"item in items\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; This could be rewritten with JavaScript’s if/else and map in a render function: render: function (createElement) &#123; if (this.items.length) &#123; return createElement('ul', this.items.map(function (item) &#123; return createElement('li', item.name) &#125;)) &#125; else &#123; return createElement('p', 'No items found.') &#125;&#125; v-modelThere is no direct v-model counterpart in render functions - you will have to implement the logic yourself: render: function (createElement) &#123; var self = this return createElement('input', &#123; domProps: &#123; value: self.value &#125;, on: &#123; input: function (event) &#123; self.value = event.target.value self.$emit('input', event.target.value) &#125; &#125; &#125;)&#125; This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to v-model. Event &amp; Key ModifiersFor the .passive, .capture and .once event modifiers, Vue offers prefixes that can be used with on: Modifier(s) Prefix .passive &amp; .capture ! .once ~ .capture.once or.once.capture ~! For example: on: &#123; '!click': this.doThisInCapturingMode, '~keyup': this.doThisOnce, `~!mouseover`: this.doThisOnceInCapturingMode&#125; For all other event and key modifiers, no proprietary prefix is necessary, because you can simply use event methods in the handler: Modifier(s) Equivalent in Handler .stop event.stopPropagation() .prevent event.preventDefault() .self if (event.target !== event.currentTarget) return Keys:.enter, .13 if (event.keyCode !== 13) return (change 13 to another key code for other key modifiers) Modifiers Keys:.ctrl, .alt, .shift, .meta if (!event.ctrlKey) return (change ctrlKey to altKey, shiftKey, or metaKey, respectively) Here’s an example with all of these modifiers used together: on: &#123; keyup: function (event) &#123; // Abort if the element emitting the event is not // the element the event is bound to if (event.target !== event.currentTarget) return // Abort if the key that went up is not the enter // key (13) and the shift key was not held down // at the same time if (!event.shiftKey || event.keyCode !== 13) return // Stop event propagation event.stopPropagation() // Prevent the default keyup handler for this element event.preventDefault() // ... &#125;&#125; SlotsYou can access static slot contents as Arrays of VNodes from this.$slots: render: function (createElement) &#123; // `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', this.$slots.default)&#125; And access scoped slots as functions that return VNodes from this.$scopedSlots: render: function (createElement) &#123; // `&lt;div&gt;&lt;slot :text=\"msg\"&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', [ this.$scopedSlots.default(&#123; text: this.msg &#125;) ])&#125; To pass scoped slots to a child component using render functions, use the scopedSlots field in VNode data: render (createElement) &#123; return createElement('div', [ createElement('child', &#123; // pass `scopedSlots` in the data object // in the form of &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement('span', props.text) &#125; &#125; &#125;) ])&#125; JSXIf you’re writing a lot of render functions, it might feel painful to write something like this: createElement( 'anchored-heading', &#123; props: &#123; level: 1 &#125; &#125;, [ createElement('span', 'Hello'), ' world!' ]) Especially when the template version is so simple in comparison: &lt;anchored-heading :level=\"1\"&gt; &lt;span&gt;Hello&lt;/span&gt; world!&lt;/anchored-heading&gt; That’s why there’s a Babel plugin to use JSX with Vue, getting us back to a syntax that’s closer to templates: import AnchoredHeading from './AnchoredHeading.vue'new Vue(&#123; el: '#demo', render (h) &#123; return ( &lt;AnchoredHeading level=&#123;1&#125;&gt; &lt;span&gt;Hello&lt;/span&gt; world! &lt;/AnchoredHeading&gt; ) &#125;&#125;) Aliasing createElement to h is a common convention you’ll see in the Vue ecosystem and is actually required for JSX. If h is not available in the scope, your app will throw an error. For more on how JSX maps to JavaScript, see the usage docs. Functional ComponentsThe anchored heading component we created earlier is relatively simple. It doesn’t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it’s just a function with some props. In cases like this, we can mark components as functional, which means that they’re stateless (no data) and instanceless (no this context). A functional component looks like this: Vue.component('my-component', &#123; functional: true, // To compensate for the lack of an instance, // we are now provided a 2nd context argument. render: function (createElement, context) &#123; // ... &#125;, // Props are optional props: &#123; // ... &#125;&#125;) Note: in versions before 2.3.0, the props option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the props option and all attributes found on the component node will be implicitly extracted as props. Everything the component needs is passed through context, which is an object containing: props: An object of the provided props children: An array of the VNode children slots: A function returning a slots object data: The entire data object passed to the component parent: A reference to the parent component listeners: (2.3.0+) An object containing parent-registered event listeners. This is simply an alias to data.on injections: (2.3.0+) if using the inject option, this will contain resolved injections. After adding functional: true, updating the render function of our anchored heading component would simply require adding the context argument, updating this.$slots.default to context.children, then updating this.level to context.props.level. Since functional components are just functions, they’re much cheaper to render. However, the lack of a persistent instance means they won’t show up in the Vue devtools component tree. They’re also very useful as wrapper components. For example, when you need to: Programmatically choose one of several other components to delegate to Manipulate children, props, or data before passing them on to a child component Here’s an example of a smart-list component that delegates to more specific components, depending on the props passed to it: var EmptyList = &#123; /* ... */ &#125;var TableList = &#123; /* ... */ &#125;var OrderedList = &#123; /* ... */ &#125;var UnorderedList = &#123; /* ... */ &#125;Vue.component('smart-list', &#123; functional: true, render: function (createElement, context) &#123; function appropriateListComponent () &#123; var items = context.props.items if (items.length === 0) return EmptyList if (typeof items[0] === 'object') return TableList if (context.props.isOrdered) return OrderedList return UnorderedList &#125; return createElement( appropriateListComponent(), context.data, context.children ) &#125;, props: &#123; items: &#123; type: Array, required: true &#125;, isOrdered: Boolean &#125;&#125;) slots() vs childrenYou may wonder why we need both slots() and children. Wouldn’t slots().default be the same as children? In some cases, yes - but what if you have a functional component with the following children? &lt;my-functional-component&gt; &lt;p slot=\"foo\"&gt; first &lt;/p&gt; &lt;p&gt;second&lt;/p&gt;&lt;/my-functional-component&gt; For this component, children will give you both paragraphs, slots().default will give you only the second, and slots().foo will give you only the first. Having both children and slots() therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by simply passing along children. Template CompilationYou may be interested to know that Vue’s templates actually compile to render functions. This is an implementation detail you usually don’t need to know about, but if you’d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using Vue.compile to live-compile a template string: render: {{ result.render }} staticRenderFns: _m({{ index }}): {{ fn }} {{ result.staticRenderFns }} Compilation Error: {{ result }} new Vue({ el: '#vue-compile-demo', data: { templateText: '\\ \\n\\ \\n\\ I\\'m a template!\\n\\ \\n\\ \\n\\ {{ message }}\\n\\ \\n\\ \\n\\ No message.\\n\\ \\n\\ \\ ', }, computed: { result: function () { if (!this.templateText) { return 'Enter a valid template above' } try { var result = Vue.compile(this.templateText.replace(/\\s{2,}/g, '')) return { render: this.formatFunction(result.render), staticRenderFns: result.staticRenderFns.map(this.formatFunction) } } catch (error) { return error.message } } }, methods: { formatFunction: function (fn) { return fn.toString().replace(/(\\{\\n)(\\S)/, '$1 $2') } } }) console.error = function (error) { throw new Error(error) } #vue-compile-demo { -webkit-user-select: inherit; user-select: inherit; } #vue-compile-demo pre { padding: 10px; overflow-x: auto; } #vue-compile-demo code { white-space: pre; padding: 0 } #vue-compile-demo textarea { width: 100%; font-family: monospace; }"},{"title":"Routing","date":"2017-07-23T06:47:55.864Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/routing.html","permalink":"https://rohmikwon.github.io/v2/guide/routing.html","excerpt":"","text":"Official RouterFor most Single Page Applications, it’s recommended to use the officially-supported vue-router library. For more details, see vue-router’s documentation. Simple Routing From ScratchIf you just need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this: const NotFound = &#123; template: '&lt;p&gt;Page not found&lt;/p&gt;' &#125;const Home = &#123; template: '&lt;p&gt;home page&lt;/p&gt;' &#125;const About = &#123; template: '&lt;p&gt;about page&lt;/p&gt;' &#125;const routes = &#123; '/': Home, '/about': About&#125;new Vue(&#123; el: '#app', data: &#123; currentRoute: window.location.pathname &#125;, computed: &#123; ViewComponent () &#123; return routes[this.currentRoute] || NotFound &#125; &#125;, render (h) &#123; return h(this.ViewComponent) &#125;&#125;) Combined with the HTML5 History API, you can build a very basic but fully-functional client-side router. To see that in practice, check out this example app. Integrating 3rd-Party RoutersIf there’s a 3rd-party router you prefer to use, such as Page.js or Director, integration is similarly easy. Here’s a complete example using Page.js."},{"title":"Single File Components","date":"2017-07-23T06:47:55.864Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/single-file-components.html","permalink":"https://rohmikwon.github.io/v2/guide/single-file-components.html","excerpt":"","text":"IntroductionIn many Vue projects, global components will be defined using Vue.component, followed by new Vue({ el: &#39;#container&#39; }) to target a container element in the body of every page. This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent: Global definitions force unique names for every component String templates lack syntax highlighting and require ugly slashes for multiline HTML No CSS support means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out No build step restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel All of these are solved by single-file components with a .vue extension, made possible with build tools such as Webpack or Browserify. Here’s a simple example of a file we’ll call Hello.vue: Now we get: Complete syntax highlighting CommonJS modules Component-scoped CSS As promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components. These specific languages are just examples. You could just as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with vue-loader, it also has first-class support for CSS Modules. What About Separation of Concerns?One important thing to note is that separation of concerns is not equal to separation of file types. In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweaves with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable. Even if you don’t like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files: &lt;!-- my-component.vue --&gt;&lt;template&gt; &lt;div&gt;This will be pre-compiled&lt;/div&gt;&lt;/template&gt;&lt;script src=\"./my-component.js\"&gt;&lt;/script&gt;&lt;style src=\"./my-component.css\"&gt;&lt;/style&gt; Getting StartedFor Users New to Module Build Systems in JavaScriptWith .vue components, we’re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven’t already: Node Package Manager (NPM): Read the Getting Started guide through section 10: Uninstalling global packages. Modern JavaScript with ES2015/16: Read through Babel’s Learn ES2015 guide. You don’t have to memorize every feature right now, but keep this page as a reference you can come back to. After you’ve taken a day to dive into these resources, we recommend checking out the webpack-simple template. Follow the instructions and you should have a Vue project with .vue components, ES2015 and hot-reloading running in no time! The template uses Webpack, a module bundler that takes a number of “modules” and then bundles them into your final application. To learn more about Webpack itself, this video offers a good intro. Once you get past the basics, you might also want to check out this advanced Webpack course on Egghead.io. In Webpack, each module can be transformed by a “loader” before being included in the bundle, and Vue offers the vue-loader plugin to take care of translating .vue single-file components. The webpack-simple template has already set up everything for you, but if you’d like to learn more about how .vue components work with Webpack, you can read the docs for vue-loader. For Advanced UsersWhether you prefer Webpack or Browserify, we have documented templates for both simple and more complex projects. We recommend browsing github.com/vuejs-templates, picking a template that’s right for you, then following the instructions in the README to generate a new project with vue-cli."},{"title":"Server-Side Rendering","date":"2017-07-23T06:47:55.865Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/ssr.html","permalink":"https://rohmikwon.github.io/v2/guide/ssr.html","excerpt":"","text":"The Complete SSR GuideWe have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at ssr.vuejs.org. Nuxt.jsProperly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: Nuxt.js. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try."},{"title":"State Management","date":"2017-07-23T06:47:55.866Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/state-management.html","permalink":"https://rohmikwon.github.io/v2/guide/state-management.html","excerpt":"","text":"Official Flux-Like ImplementationLarge applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers vuex: our own Elm-inspired state management library. It even integrates into vue-devtools, providing zero-setup access to time travel. Information for React DevelopersIf you’re coming from React, you may be wondering how vuex compares to redux, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via some simple bindings. Vuex is different in that it knows it’s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience. Simple State Management from ScratchIt is often overlooked that the source of truth in Vue applications is the raw data object - a Vue instance simply proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can simply share it by identity: const sourceOfTruth = &#123;&#125;const vmA = new Vue(&#123; data: sourceOfTruth&#125;)const vmB = new Vue(&#123; data: sourceOfTruth&#125;) Now whenever sourceOfTruth is mutated, both vmA and vmB will update their views automatically. Subcomponents within each of these instances would also have access via this.$root.$data. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace. To help solve this problem, we can adopt a simple store pattern: var store = &#123; debug: true, state: &#123; message: 'Hello!' &#125;, setMessageAction (newValue) &#123; if (this.debug) console.log('setMessageAction triggered with', newValue) this.state.message = newValue &#125;, clearMessageAction () &#123; if (this.debug) console.log('clearMessageAction triggered') this.state.message = '' &#125;&#125; Notice all actions that mutate the store’s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how are they triggered. Now when something goes wrong, we’ll also have a log of what happened leading up to the bug. In addition, each instance/component can still own and manage its own private state: var vmA = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;)var vmB = new Vue(&#123; data: &#123; privateState: &#123;&#125;, sharedState: store.state &#125;&#125;) It’s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed. As we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the Flux architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel. This brings us full circle back to vuex, so if you’ve read this far it’s probably time to try it out!"},{"title":"Meet the Team","date":"2017-07-23T06:47:55.867Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/team.html","permalink":"https://rohmikwon.github.io/v2/guide/team.html","excerpt":"","text":"{{ profile.name }} Core focus {{ repo }} Ecosystem {{ repo }} Work Distance About {{ textDistance }} away {{ textDistance }} away in {{ profile.city }} City {{ profile.city }} Languages Links {{ minimizeLink(link) }} Github Twitter The Core Team find near me Failed to get your location. The development of Vue and its ecosystem is guided by an international team, some of whom have chosen to be featured below. The core team has been sorted by their distance from you. Community Partners find near me Failed to get your location. Some members of the Vue community have so enriched it, that they deserve special mention. We've developed a more intimate relationship with these key partners, often coordinating with them on upcoming features and news. The community partners have been sorted by their distance from you. (function () { var cityCoordsFor = { 'Annecy, France': [45.899247, 6.129384], 'Alicante, Spain' : [38.346543, -0.483838], 'Bangalore, India': [12.971599, 77.594563], 'Bordeaux, France': [44.837789, -0.579180], 'Bucharest, Romania': [44.426767, 26.102538], 'Chengdu, China': [30.572815, 104.066801], 'Chongqing, China': [29.431586, 106.912251], 'Denver, CO, USA': [39.739236, -104.990251], 'Dubna, Russia': [56.732020, 37.166897], 'East Lansing, MI, USA': [42.736979, -84.483865], 'Hangzhou, China': [30.274084, 120.155070], 'Jersey City, NJ, USA': [40.728157, -74.558716], 'Kingston, Jamaica': [18.017874, -76.809904], 'Krasnodar, Russia': [45.039267, 38.987221], 'Lansing, MI, USA': [42.732535, -84.555535], 'London, UK': [51.507351, -0.127758], 'Lyon, France': [45.764043, 4.835659], 'Mannheim, Germany': [49.487459, 8.466039], 'Moscow, Russia': [55.755826, 37.617300], 'Orlando, FL, USA': [28.538335, -81.379236], 'Paris, France': [48.856614, 2.352222], 'Seoul, South Korea': [37.566535, 126.977969], 'Shanghai, China': [31.230390, 121.473702], 'Taquaritinga, Brazil': [-21.430094, -48.515285], 'Tehran, Iran': [35.689197, 51.388974], 'Thessaloniki, Greece': [40.640063, 22.944419], 'Tokyo, Japan': [35.689487, 139.691706], 'Toronto, Canada': [43.653226, -79.383184], 'Wrocław, Poland': [51.107885, 17.038538] } var languageNameFor = { en: 'English', zh: '中文', vi: 'Tiếng Việt', pl: 'Polski', pt: 'Português', ru: 'Русский', jp: '日本語', fr: 'Français', de: 'Deutsch', el: 'Ελληνικά', es: 'Español', hi: 'हिंदी', fa: 'فارسی', ko: '한국어', ro: 'Română' } var team = [{ name: 'Evan You', title: 'Benevolent Dictator For Life', city: 'Jersey City, NJ, USA', languages: ['zh', 'en'], github: 'yyx990803', twitter: 'youyuxi', work: { role: 'Creator', org: 'Vue.js' }, reposOfficial: [ 'vuejs/*', 'vuejs-templates/*' ], links: [ 'https://www.patreon.com/evanyou' ] }] team = team.concat(shuffle([ { name: 'Chris Fritz', title: 'Good Word Putter-Togetherer', city: 'Lansing, MI, USA', languages: ['en', 'de'], github: 'chrisvfritz', twitter: 'chrisvfritz', work: { role: 'Educator & Consultant' }, reposOfficial: [ 'vuejs.org', 'vue-migration-helper' ], reposPersonal: [ 'vue-2.0-simple-routing-example', 'vue-ssr-demo-simple' ] }, { name: 'Eduardo', title: 'Real-Time Rerouter', city: 'Paris, France', languages: ['es', 'fr', 'en'], github: 'posva', twitter: 'posva', work: { role: 'Lead Instructor', org: 'IronHack', orgUrl: 'https://www.ironhack.com/' }, reposOfficial: [ 'vuefire', 'vue-router' ], reposPersonal: [ 'vuexfire', 'vue-mdc', 'vue-motion' ], links: [ 'https://www.codementor.io/posva' ] }, { name: 'Jinjiang', title: 'Mobile Extrapolator', city: 'Hangzhou, China', languages: ['zh', 'en'], github: 'jinjiang', twitter: 'zhaojinjiang', work: { org: 'Alibaba', orgUrl: 'https://www.alibaba.com/' }, reposOfficial: [ 'cn.vuejs.org' ], reposPersonal: [ 'apache/incubator-weex' ] }, { name: 'EGOIST', title: 'Build Tool Simplificator', city: 'Chengdu, China', languages: ['zh', 'en'], github: 'egoist', twitter: 'rem_rin_rin', reposOfficial: [ 'vue-cli' ], reposPersonal: [ 'poi', 'ream', 'vue-play' ] }, { name: 'Katashin', title: 'One of a Type State Manager', city: 'Tokyo, Japan', languages: ['jp', 'en'], work: { org: 'oRo Co., Ltd.', orgUrl: 'https://www.oro.com' }, github: 'ktsn', twitter: 'ktsn', reposOfficial: [ 'vuex', 'vue-class-component' ] }, { name: 'Kazupon', title: 'Validated Internationalizing Missionary', city: 'Tokyo, Japan', languages: ['jp', 'en'], github: 'kazupon', twitter: 'kazu_pon', work: { role: 'CTO & Full Stack Developer' }, reposOfficial: [ 'vuejs.org', 'jp.vuejs.org' ], reposPersonal: [ 'vue-i18n', 'vue-i18n-loader', 'vue-validator' ], links: [ 'https://cuusoo.com', 'http://frapwings.jp' ] }, { name: 'Rahul Kadyan', title: 'Ecosystem Glue Chemist', city: 'Bangalore, India', languages: ['hi', 'en'], work: { role: 'Software Engineer', org: 'Myntra', orgUrl: 'https://www.myntra.com/' }, github: 'znck', twitter: 'znck0', reposOfficial: [ 'rollup-plugin-vue', 'vue-issue-helper' ], reposPersonal: [ 'vue-keynote', 'bootstrap-for-vue', 'vue-interop' ], links: [ 'https://znck.me', 'https://www.codementor.io/znck' ] }, { name: 'Alan Song', title: 'Regent of Routing', city: 'Hangzhou, China', languages: ['zh', 'en'], work: { role: 'Cofounder', org: 'Futurenda', orgUrl: 'https://www.futurenda.com/' }, github: 'fnlctrl', reposOfficial: [ 'vue-router' ] }, { name: 'Blake Newman', title: 'Performance Specializer & Code Deleter', city: 'London, UK', languages: ['en'], work: { role: 'Software Engineer', org: 'Attest', orgUrl: 'https://www.askattest.com/' }, github: 'blake-newman', twitter: 'blake-newman', reposOfficial: [ 'vuex', 'vue-router', 'vue-loader' ] }, { name: 'Phan An', title: 'Backend Designer & Process Poet', city: 'London, UK', languages: ['vi', 'en'], github: 'phanan', twitter: 'notphanan', reposOfficial: [ 'vuejs.org' ], reposPersonal: [ 'vuequery', 'vue-google-signin-button' ], links: [ 'https://phanan.net/' ] }, { name: 'Linusborg', title: 'Hive-Mind Community Wrangler (Probably a Bot)', city: 'Mannheim, Germany', languages: ['de', 'en'], github: 'LinusBorg', twitter: 'Linus_Borg', reposOfficial: [ 'vuejs/*', 'vuejs-templates/*', 'vue-touch' ], reposPersonal: [ 'portal-vue' ], links: [ 'https://forum.vuejs.org/' ] }, { name: 'Denis Karabaza', title: 'Director of Directives (Emoji-Human Hybrid)', city: 'Dubna, Russia', languages: ['ru', 'en'], github: 'simplesmiler', twitter: 'simplesmiler', work: { role: 'Software Engineer', org: 'Neolant', orgUrl: 'http://neolant.ru/' }, reposPersonal: [ 'vue-focus', 'vue-clickaway' ], links: [ 'mailto:denis.karabaza@gmail.com' ] }, { name: 'Guillaume Chau', title: 'Client-Server Astronaut', city: 'Lyon, France', languages: ['fr', 'en'], github: 'Akryum', twitter: 'Akryum', reposOfficial: [ 'vue-curated' ], reposPersonal: [ 'vue-apollo', 'vue-meteor', 'vue-virtual-scroller' ] }, { name: 'Edd Yerburgh', title: 'Testatron Alpha 9000', city: 'London, UK', languages: ['en'], github: 'eddyerburgh', twitter: 'EddYerburgh', work: { role: 'Full Stack Developer' }, reposOfficial: [ 'vue-test-utils' ], reposPersonal: [ 'avoriaz' ], links: [ 'https://www.eddyerburgh.me' ] }, { name: 'defcc', title: 'Details Deity & Bug Surgeon', city: 'Chongqing, China', languages: ['zh', 'en'], github: 'defcc', work: { org: 'zbj.com', orgUrl: 'http://www.zbj.com/' }, reposOfficial: [ 'vue', 'vuejs.org', 'cn.vuejs.org' ], reposPersonal: [ 'weexteam/weex-vue-framework', 'into-vue' ] }, { name: 'gebilaoxiong', title: 'Issue Annihilator', city: 'Chongqing, China', languages: ['zh', 'en'], github: 'gebilaoxiong', work: { org: 'zbj.com', orgUrl: 'http://www.zbj.com/' }, reposOfficial: [ 'vue' ] }, { name: 'Andrew Tomaka', title: 'The Server Server', city: 'East Lansing, MI, USA', languages: ['en'], github: 'atomaka', twitter: 'atomaka', reposOfficial: [ 'vuejs/*' ], work: { org: 'Michigan State University', orgUrl: 'https://msu.edu/' }, links: [ 'https://atomaka.com/' ] } ])) var partners = [ { name: 'Sebastien Chopin', title: '#1 Nuxt Brother', city: 'Paris, France', languages: ['fr', 'en'], github: 'Atinux', twitter: 'Atinux', work: { org: 'Orion', orgUrl: 'https://orion.sh' }, reposPersonal: [ 'nuxt/*', 'nuxt-community/*', 'declandewet/vue-meta' ] }, { name: 'Alexandre Chopin', title: '#1 Nuxt Brother', city: 'Bordeaux, France', languages: ['fr', 'en'], github: 'alexchopin', twitter: 'ChopinAlexandre', work: { org: 'Orion', orgUrl: 'https://orion.sh' }, reposPersonal: [ 'nuxt/*', 'nuxt-community/*', 'vue-flexboxgrid' ] }, { name: 'Khary Sharpe', title: 'Viral Newscaster', city: 'Kingston, Jamaica', languages: ['en'], github: 'kharysharpe', twitter: 'kharysharpe', links: [ 'https://twitter.com/VueJsNews', 'http://www.kharysharpe.com/' ] }, { name: 'Damian Dulisz', title: 'Dark Mage of Plugins, News, and Confs', city: 'Wrocław, Poland', languages: ['pl', 'en'], github: 'shentao', twitter: 'DamianDulisz', work: { role: 'Senior Frontend Developer', org: 'Monterail', orgUrl: 'https://www.monterail.com/' }, reposPersonal: [ 'monterail/vue-multiselect', 'monterail/vue-newsletter', 'monterail/vuelidate' ] }, { name: 'Alex Kyriakidis', title: 'Vueducator Extraordinaire', city: 'Thessaloniki, Greece', languages: ['el', 'en'], github: 'hootlex', twitter: 'hootlex', work: { role: 'Consultant / Author' }, reposPersonal: [ 'vuejs-paginator', 'vuedo/vuedo', 'the-majesty-of-vuejs-2' ], links: [ 'https://vuejsfeed.com/', 'https://vueschool.io/' ] }, { name: 'Pooya Parsa', title: 'Nuxtification Modularizer', city: 'Tehran, Iran', languages: ['fa', 'en'], github: 'pi0', twitter: '_pi0_', work: { role: 'Technical Advisor', org: 'Fandogh (AUT University)', orgUrl: 'https://fandogh.org' }, reposPersonal: [ 'nuxt/nuxt.js', 'nuxt-community/modules', 'bootstrap-vue/bootstrap-vue' ] }, { name: 'Yi Yang', city: 'Shanghai, China', title: 'Interface Elementologist', languages: ['zh', 'en'], github: 'Leopoldthecoder', work: { org: 'ele.me', orgUrl: 'https://www.ele.me', }, reposPersonal: [ 'elemefe/element', 'elemefe/mint-ui' ] }, { name: 'Bruno Lesieur', title: 'French Community Directeur', city: 'Annecy, France', languages: ['fr', 'en'], github: 'Haeresis', twitter: 'MachinisteWeb', work: { role: 'Cofounder', org: 'Orchard ID', orgUrl: 'https://www.orchard-id.com/' }, reposPersonal: [ 'vuejs-fr/vuejs.org', 'Haeresis/node-atlas-hello-vue' ], links: [ 'https://node-atlas.js.org/', 'https://blog.lesieur.name/' ] }, { name: 'ChangJoo Park', title: 'Vuenthusiastic Korean Community Organizer', city: 'Seoul, South Korea', languages: ['ko', 'en'], github: 'changjoo-park', twitter: 'pcjpcj2', reposPersonal: [ 'vuejs-kr/kr.vuejs.org', 'ChangJoo-Park/vue-component-generator' ], links: [ 'https://vuejs-kr.github.io', 'https://twitter.com/pcjpcj2' ] }, { name: 'Erick Petrucelli', title: 'Perfectionist Chief Translator for Portuguese', city: 'Taquaritinga, Brazil', languages: ['pt', 'en'], github: 'ErickPetru', twitter: 'erickpetru', work: { role: 'Teacher', org: 'Fatec Taquaritinga', orgUrl: 'http://www.fatectq.edu.br/' }, reposPersonal: [ 'vuejs-br/br.vuejs.org', 'ErickPetru/vue-feathers-chat' ] }, { name: 'Razvan Stoenescu', title: 'Deep Space Quasar Creator', city: 'Bucharest, Romania', languages: ['ro', 'en'], github: 'rstoenescu', twitter: 'quasarframework', work: { role: 'Developer', org: 'Quasar Framework', orgUrl: 'http://quasar-framework.org/' }, reposPersonal: [ 'quasarframework/quasar', 'quasarframework/quasar-cli', 'quasarframework/quasar-play' ] }, { name: 'Jilson Thomas', title: 'Vue Promoter and VueJobs Guy', city: 'Toronto, Canada', languages: ['en'], github: 'JillzTom', twitter: 'jilsonthomas', work: { role: 'Senior Frontend Developer', org: 'Nominator', orgUrl: 'https://nominator.com/' }, links: [ 'https://vuejobs.com' ] }, { name: 'Israel Ortuño', title: 'VueJobs Buccaneer', city: 'Alicante, Spain', languages: ['es', 'en'], github: 'IsraelOrtuno', twitter: 'IsraelOrtuno', work: { role: 'Full Stack Web Developer', org: 'Freelance' }, links: [ 'https://vuejobs.com' ] }, { name: 'John Leider', title: 'Vuetiful Framework Sculptor', city: 'Orlando, FL, USA', languages: ['en'], github: 'vuetifyjs', twitter: 'vuetifyjs', work: { role: 'Developer', org: 'Fast Forward Academy', orgUrl: 'https://fastforwardacademy.com' }, reposPersonal: [ 'vuetifyjs/vuetify' ] }, { name: 'Grigoriy Beziuk', title: 'Translation Gang Leader', city: 'Moscow, Russia', languages: ['ru', 'de', 'en'], github: 'gbezyuk', work: { role: 'Full Stack Web Developer', org: 'Self Employed', orgUrl: 'http://gbezyuk.ru' }, reposPersonal: [ 'translation-gang/ru.vuejs.org' ] }, { name: 'Alexander Sokolov', title: 'Russian Translation Sharp Eye', city: 'Krasnodar, Russia', languages: ['ru', 'en'], github: 'Alex-Sokolov', reposPersonal: [ 'translation-gang/ru.vuejs.org' ] }, { name: 'Sarah Drasner', city: 'Denver, CO, USA', languages: ['en'], work: { role: 'Consultant' }, github: 'sdras', twitter: 'sarah_edo', codepen: 'sdras', reposPersonal: [ 'intro-to-vue', 'vue-sublime-snippets', 'nuxt-type', 'animating-vue-workshop', 'vue-wine-label', 'vue-weather-notifier' ] } ] Vue.component('vuer-profile', { template: '#vuer-profile-template', props: { profile: Object, titleVisible: Boolean }, computed: { workHtml: function () { var work = this.profile.work var html = '' if (work.orgUrl) { html += '' if (work.org) { html += work.org } else { this.minimizeLink(work.orgUrl) } html += '' } else if (work.org) { html += work.org } if (work.role) { if (html.length > 0) { html = work.role + ' @ ' + html } else { html = work.role } } return html }, textDistance: function () { var distanceInKm = this.profile.distanceInKm || 0 if (this.$root.useMiles) { return roundDistance(kmToMi(distanceInKm)) + ' miles' } else { return roundDistance(distanceInKm) + ' km' } }, languageListHtml: function () { var vm = this var nav = window.navigator if (!vm.profile.languages) return '' var preferredLanguageCode = nav.languages // The preferred language set in the browser ? nav.languages[0] : ( // The system language in IE nav.userLanguage || // The language in the current page nav.language ) return ( '' + vm.profile.languages.map(function (languageCode, index) { var language = languageNameFor[languageCode] if ( languageCode !== 'en' && languageCode === preferredLanguageCode.slice(0, 2) ) { return ( '' + language + '' ) } return language }).join('') + '' ) } }, methods: { minimizeLink: function (link) { return link .replace(/^https?:\\/\\/(www\\.)?/, '') .replace(/\\/$/, '') .replace(/^mailto:/, '') }, /** * Generate a GitHub URL using a repo and a handle. */ githubUrl: function (handle, repo) { if (repo && repo.indexOf('/') !== -1) { // If the repo name has a slash, it must be an organization repo. // In such a case, we discard the (personal) handle. return ( 'https://github.com/' + repo.replace(/\\/\\*$/, '') ) } return 'https://github.com/' + handle + '/' + (repo || '') } } }) new Vue({ el: '#team-members', data: { team: team, partners: shuffle(partners), geolocationSupported: false, isSorting: false, errorGettingLocation: false, userPosition: null, useMiles: false, konami: { position: 0, code: [38, 38, 40, 40, 37, 39, 37, 39, 66, 65] } }, computed: { sortedTeam: function () { return this.sortVuersByDistance(this.team) }, sortedPartners: function () { return this.sortVuersByDistance(this.partners) }, titleVisible: function () { return this.konami.code.length === this.konami.position } }, created: function () { var nav = window.navigator if ('geolocation' in nav) { this.geolocationSupported = true var imperialLanguageCodes = [ 'en-US', 'en-MY', 'en-MM', 'en-BU', 'en-LR', 'my', 'bu' ] if (imperialLanguageCodes.indexOf(nav.language) !== -1) { this.useMiles = true } } document.addEventListener('keydown', this.konamiKeydown) }, beforeDestroy: function () { document.removeEventListener('keydown', this.konamiKeydown) }, methods: { getUserPosition: function () { var vm = this var nav = window.navigator vm.isSorting = true nav.geolocation.getCurrentPosition( function (position) { vm.userPosition = position vm.isSorting = false }, function (error) { vm.isSorting = false vm.errorGettingLocation = true }, { enableHighAccuracy: true } ) }, sortVuersByDistance: function (vuers) { var vm = this if (!vm.userPosition) return vuers var vuersWithDistances = vuers.map(function (vuer) { var cityCoords = cityCoordsFor[vuer.city] return Object.assign({}, vuer, { distanceInKm: getDistanceFromLatLonInKm( vm.userPosition.coords.latitude, vm.userPosition.coords.longitude, cityCoords[0], cityCoords[1] ) }) }) vuersWithDistances.sort(function (a, b) { return ( a.distanceInKm - b.distanceInKm ) }) return vuersWithDistances }, konamiKeydown: function (event) { if (this.titleVisible) { return } if (event.keyCode !== this.konami.code[this.konami.position++]) { this.konami.position = 0 } } } }) /** * Shuffles array in place. * @param {Array} a items The array containing the items. */ function shuffle (a) { a = a.concat([]) if (window.location.hostname === 'localhost') { return a } var j, x, i for (i = a.length; i; i--) { j = Math.floor(Math.random() * i) x = a[i - 1] a[i - 1] = a[j] a[j] = x } return a } /** * Calculates great-circle distances between the two points – that is, the shortest distance over the earth’s surface – using the Haversine formula. * @param {Number} lat1 The latitude of the 1st location. * @param {Number} lon1 The longitute of the 1st location. * @param {Number} lat2 The latitude of the 2nd location. * @param {Number} lon2 The longitute of the 2nd location. */ function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) { var R = 6371 // Radius of the earth in km var dLat = deg2rad(lat2-lat1) // deg2rad below var dLon = deg2rad(lon2-lon1) var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2) var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)) var d = R * c // Distance in km return d } function deg2rad(deg) { return deg * (Math.PI/180) } function kmToMi (km) { return km * 0.62137 } function roundDistance (num) { return Number(Math.ceil(num).toPrecision(2)) } })()"},{"title":"Transitioning State","date":"2017-07-23T06:47:55.868Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/transitioning-state.html","permalink":"https://rohmikwon.github.io/v2/guide/transitioning-state.html","excerpt":"","text":"Vue’s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example: numbers and calculations colors displayed the positions of SVG nodes the sizes and other properties of elements All of these are either already stored as raw numbers or can be converted into numbers. Once we do that, we can animate these state changes using 3rd-party libraries to tween state, in combination with Vue’s reactivity and component systems. Animating State with WatchersWatchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let’s dive into an example using Tween.js: &lt;script src=\"https://unpkg.com/tween.js@16.3.4\"&gt;&lt;/script&gt;&lt;div id=\"animated-number-demo\"&gt; &lt;input v-model.number=\"number\" type=\"number\" step=\"20\"&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt; new Vue(&#123; el: '#animated-number-demo', data: &#123; number: 0, animatedNumber: 0 &#125;, watch: &#123; number: function(newValue, oldValue) &#123; var vm = this function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(&#123; tweeningNumber: oldValue &#125;) .easing(TWEEN.Easing.Quadratic.Out) .to(&#123; tweeningNumber: newValue &#125;, 500) .onUpdate(function () &#123; vm.animatedNumber = this.tweeningNumber.toFixed(0) &#125;) .start() animate() &#125; &#125;&#125;) {{ animatedNumber }} new Vue({ el: '#animated-number-demo', data: { number: 0, animatedNumber: 0 }, watch: { number: function(newValue, oldValue) { var vm = this function animate () { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween({ tweeningNumber: oldValue }) .easing(TWEEN.Easing.Quadratic.Out) .to({ tweeningNumber: newValue }, 500) .onUpdate(function () { vm.animatedNumber = this.tweeningNumber.toFixed(0) }) .start() animate() } } }) When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn’t directly stored as a number, like any valid CSS color for example? Here’s how we could accomplish this with the addition of Color.js: &lt;script src=\"https://unpkg.com/tween.js@16.3.4\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/color-js@1.0.3/color.js\"&gt;&lt;/script&gt;&lt;div id=\"example-7\"&gt; &lt;input v-model=\"colorQuery\" v-on:keyup.enter=\"updateColor\" placeholder=\"Enter a color\" &gt; &lt;button v-on:click=\"updateColor\"&gt;Update&lt;/button&gt; &lt;p&gt;Preview:&lt;/p&gt; &lt;span v-bind:style=\"&#123; backgroundColor: tweenedCSSColor &#125;\" class=\"example-7-color-preview\" &gt;&lt;/span&gt; &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;&lt;/div&gt; var Color = net.brehaut.Colornew Vue(&#123; el: '#example-7', data: &#123; colorQuery: '', color: &#123; red: 0, green: 0, blue: 0, alpha: 1 &#125;, tweenedColor: &#123;&#125; &#125;, created: function () &#123; this.tweenedColor = Object.assign(&#123;&#125;, this.color) &#125;, watch: &#123; color: function () &#123; function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() &#125; &#125;, computed: &#123; tweenedCSSColor: function () &#123; return new Color(&#123; red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha &#125;).toCSS() &#125; &#125;, methods: &#123; updateColor: function () &#123; this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' &#125; &#125;&#125;) .example-7-color-preview &#123; display: inline-block; width: 50px; height: 50px;&#125; Update Preview: {{ tweenedCSSColor }} var Color = net.brehaut.Color new Vue({ el: '#example-7', data: { colorQuery: '', color: { red: 0, green: 0, blue: 0, alpha: 1 }, tweenedColor: {} }, created: function () { this.tweenedColor = Object.assign({}, this.color) }, watch: { color: function () { function animate () { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() } }, computed: { tweenedCSSColor: function () { return new Color({ red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha }).toCSS() } }, methods: { updateColor: function () { this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' } } }) .example-7-color-preview { display: inline-block; width: 50px; height: 50px; } Dynamic State TransitionsJust as with Vue’s transition components, the data backing state transitions can be updated in real time, which is especially useful for prototyping! Even using a simple SVG polygon, you can achieve many effects that would be difficult to conceive of until you’ve played with the variables a little. Sides: {{ sides }} Minimum Radius: {{ minRadius }}% Update Interval: {{ updateInterval }} milliseconds new Vue({ el: '#svg-polygon-demo', data: function () { var defaultSides = 10 var stats = Array.apply(null, { length: defaultSides }) .map(function () { return 100 }) return { stats: stats, points: generatePoints(stats), sides: defaultSides, minRadius: 50, interval: null, updateInterval: 500 } }, watch: { sides: function (newSides, oldSides) { var sidesDifference = newSides - oldSides if (sidesDifference > 0) { for (var i = 1; i"},{"title":"TypeScript Support","date":"2017-07-23T06:47:55.869Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/typescript.html","permalink":"https://rohmikwon.github.io/v2/guide/typescript.html","excerpt":"","text":"Important 2.2.0+ Change Notice for TS + webpack 2 usersIn Vue 2.2.0+ we introduced dist files exposed as ES modules, which will be used by default by webpack 2. Unfortunately, this introduced an unintentional breaking change because with TypeScript + webpack 2, import Vue = require(&#39;vue&#39;) will now return a synthetic ES module object instead of Vue itself. We plan to move all official declarations to use ES-style exports in the future. Please see Recommended Configuration below on a future-proof setup. Official Declaration in NPM PackagesA static type system can help prevent many potential runtime errors, especially as applications grow. That’s why Vue ships with official type declarations for TypeScript - not only in Vue core, but also for vue-router and vuex as well. Since these are published on NPM, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don’t need any additional tooling to use TypeScript with Vue. Recommended Configuration// tsconfig.json&#123; \"compilerOptions\": &#123; // ... other options omitted \"allowSyntheticDefaultImports\": true, \"lib\": [ \"dom\", \"es5\", \"es2015.promise\" ] &#125;&#125; Note the allowSyntheticDefaultImports option allows us to use the following: import Vue from 'vue' instead of: import Vue = require('vue') The former (ES module syntax) is recommended because it is consistent with recommended plain ES usage, and in the future we are planning to move all official declarations to use ES-style exports. In addition, if you are using TypeScript with webpack 2, the following is also recommended: &#123; \"compilerOptions\": &#123; // ... other options omitted \"module\": \"es2015\", \"moduleResolution\": \"node\" &#125;&#125; This tells TypeScript to leave the ES module import statements intact, which in turn allows webpack 2 to take advantage of ES-module-based tree-shaking. See TypeScript compiler options docs for more details. Using Vue’s Type DeclarationsVue’s type definition exports many useful type declarations. For example, to annotate an exported component options object (e.g. in a .vue file): import Vue, &#123; ComponentOptions &#125; from 'vue'export default &#123; props: ['message'], template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125; as ComponentOptions&lt;Vue&gt; Class-Style Vue ComponentsVue component options can easily be annotated with types: import Vue, &#123; ComponentOptions &#125; from 'vue'// Declare the component's typeinterface MyComponent extends Vue &#123; message: string onClick (): void&#125;export default &#123; template: '&lt;button @click=\"onClick\"&gt;Click!&lt;/button&gt;', data: function () &#123; return &#123; message: 'Hello!' &#125; &#125;, methods: &#123; onClick: function () &#123; // TypeScript knows that `this` is of type MyComponent // and that `this.message` will be a string window.alert(this.message) &#125; &#125;// We need to explicitly annotate the exported options object// with the MyComponent type&#125; as ComponentOptions&lt;MyComponent&gt; Unfortunately, there are a few limitations here: TypeScript can’t infer all types from Vue’s API. For example, it doesn’t know that the message property returned in our data function will be added to the MyComponent instance. That means if we assigned a number or boolean value to message, linters and compilers wouldn’t be able to raise an error, complaining that it should be a string. Because of the previous limitation, annotating types like this can be verbose. The only reason we have to manually declare message as a string is because TypeScript can’t infer the type in this case. Fortunately, vue-class-component can solve both of these problems. It’s an official companion library that allows you to declare components as native JavaScript classes, with a @Component decorator. As an example, let’s rewrite the above component: import Vue from 'vue'import Component from 'vue-class-component'// The @Component decorator indicates the class is a Vue component@Component(&#123; // All component options are allowed in here template: '&lt;button @click=\"onClick\"&gt;Click!&lt;/button&gt;'&#125;)export default class MyComponent extends Vue &#123; // Initial data can be declared as instance properties message: string = 'Hello!' // Component methods can be declared as instance methods onClick (): void &#123; window.alert(this.message) &#125;&#125; With this syntax alternative, our component definition is not only shorter, but TypeScript can also infer the types of message and onClick without explicit interface declarations. This strategy even allows you to handle types for computed properties, lifecycle hooks, and render functions. For full usage details, see the vue-class-component docs."},{"title":"Transition Effects","date":"2017-07-23T06:47:55.868Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/transitions.html","permalink":"https://rohmikwon.github.io/v2/guide/transitions.html","excerpt":"","text":"OverviewVue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to: automatically apply classes for CSS transitions and animations integrate 3rd-party CSS animation libraries, such as Animate.css use JavaScript to directly manipulate the DOM during transition hooks integrate 3rd-party JavaScript animation libraries, such as Velocity.js On this page, we’ll only cover entering, leaving, and list transitions, but you can see the next section for managing state transitions. Transitioning Single Elements/ComponentsVue provides a transition wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts: Conditional rendering (using v-if) Conditional display (using v-show) Dynamic components Component root nodes This is what a very simple example looks like in action: &lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) .fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0&#125; Toggle hello new Vue({ el: '#demo', data: { show: true } }) .demo-transition-enter-active, .demo-transition-leave-active { transition: opacity .5s } .demo-transition-enter, .demo-transition-leave-to { opacity: 0 } When an element wrapped in a transition component is inserted or removed, this is what happens: Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings. If the transition component provided JavaScript hooks, these hooks will be called at appropriate timings. If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue’s concept of nextTick). Transition ClassesThere are six classes applied for enter/leave transitions. v-enter: Starting state for enter. Added before element is inserted, removed one frame after element is inserted. v-enter-active: Active state for enter. Applied during the entire entering phase. Added before element is inserted, removed when transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition. v-enter-to: Only available in versions 2.1.8+. Ending state for enter. Added one frame after element is inserted (at the same time v-enter is removed), removed when transition/animation finishes. v-leave: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame. v-leave-active: Active state for leave. Applied during the entire leaving phase. Added immediately when leave transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition. v-leave-to: Only available in versions 2.1.8+. Ending state for leave. Added one frame after a leaving transition is triggered (at the same time v-leave is removed), removed when the transition/animation finishes. Each of these classes will be prefixed with the name of the transition. Here the v- prefix is the default when you use a &lt;transition&gt; element with no name. If you use &lt;transition name=&quot;my-transition&quot;&gt; for example, then the v-enter class would instead be my-transition-enter. v-enter-active and v-leave-active give you the ability to specify different easing curves for enter/leave transitions, which you’ll see an example of in the following section. CSS TransitionsOne of the most common transition types uses CSS transitions. Here’s a simple example: &lt;div id=\"example-1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;) /* Enter and leave animations can use different *//* durations and timing functions. */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; Toggle render hello new Vue({ el: '#example-1', data: { show: true } }) .slide-fade-enter-active { transition: all .3s ease; } .slide-fade-leave-active { transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); } .slide-fade-enter, .slide-fade-leave-to { transform: translateX(10px); opacity: 0; } CSS AnimationsCSS animations are applied in the same way as CSS transitions, the difference being that v-enter is not removed immediately after the element is inserted, but on an animationend event. Here’s an example, omitting prefixed CSS rules for the sake of brevity: &lt;div id=\"example-2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\"&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;) .bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; Toggle show Look at me! .bounce-enter-active { -webkit-animation: bounce-in .5s; animation: bounce-in .5s; } .bounce-leave-active { -webkit-animation: bounce-in .5s reverse; animation: bounce-in .5s reverse; } @keyframes bounce-in { 0% { -webkit-transform: scale(0); transform: scale(0); } 50% { -webkit-transform: scale(1.5); transform: scale(1.5); } 100% { -webkit-transform: scale(1); transform: scale(1); } } @-webkit-keyframes bounce-in { 0% { -webkit-transform: scale(0); transform: scale(0); } 50% { -webkit-transform: scale(1.5); transform: scale(1.5); } 100% { -webkit-transform: scale(1); transform: scale(1); } } new Vue({ el: '#example-2', data: { show: true } }) Custom Transition ClassesYou can also specify custom transition classes by providing the following attributes: enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) These will override the conventional class names. This is especially useful when you want to combine Vue’s transition system with an existing CSS animation library, such as Animate.css. Here’s an example: &lt;link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;) Toggle render hello new Vue({ el: '#example-3', data: { show: true } }) Using Transitions and Animations TogetherVue needs to attach event listeners in order to know when a transition has ended. It can either be transitionend or animationend, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type. However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a type attribute, with a value of either animation or transition. Explicit Transition Durations New in 2.2.0+ In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first transitionend or animationend event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element. In such cases you can specify an explicit transition duration (in milliseconds) using the duration prop on the &lt;transition&gt; component: &lt;transition :duration=\"1000\"&gt;...&lt;/transition&gt; You can also specify separate values for enter and leave durations: &lt;transition :duration=\"&#123; enter: 500, leave: 800 &#125;\"&gt;...&lt;/transition&gt; JavaScript HooksYou can also define JavaScript hooks in attributes: &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; // ...methods: &#123; // -------- // ENTERING // -------- beforeEnter: function (el) &#123; // ... &#125;, // the done callback is optional when // used in combination with CSS enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // LEAVING // -------- beforeLeave: function (el) &#123; // ... &#125;, // the done callback is optional when // used in combination with CSS leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled only available with v-show leaveCancelled: function (el) &#123; // ... &#125;&#125; These hooks can be used in combination with CSS transitions/animations or on their own. When using JavaScript-only transitions, the done callbacks are required for the enter and leave hooks. Otherwise, they will be called synchronously and the transition will finish immediately. It’s also a good idea to explicitly add v-bind:css=&quot;false&quot; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition. Now let’s dive into an example. Here’s a simple JavaScript transition using Velocity.js: &lt;!--Velocity works very much like jQuery.animate and isa great option for JavaScript animations--&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example-4\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" v-bind:css=\"false\" &gt; &lt;p v-if=\"show\"&gt; Demo &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; new Vue(&#123; el: '#example-4', data: &#123; show: false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: '1.4em' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: '1em' &#125;, &#123; complete: done &#125;) &#125;, leave: function (el, done) &#123; Velocity(el, &#123; translateX: '15px', rotateZ: '50deg' &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: '100deg' &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;&#125;) Toggle Demo new Vue({ el: '#example-4', data: { show: false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.transformOrigin = 'left' }, enter: function (el, done) { Velocity(el, { opacity: 1, fontSize: '1.4em' }, { duration: 300 }) Velocity(el, { fontSize: '1em' }, { complete: done }) }, leave: function (el, done) { Velocity(el, { translateX: '15px', rotateZ: '50deg' }, { duration: 600 }) Velocity(el, { rotateZ: '100deg' }, { loop: 2 }) Velocity(el, { rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 }, { complete: done }) } } }) Transitions on Initial RenderIf you also want to apply a transition on the initial render of a node, you can add the appear attribute: &lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; By default, this will use the transitions specified for entering and leaving. If you’d like however, you can also specify custom CSS classes: &lt;transition appear appear-class=\"custom-appear-class\" appear-to-class=\"custom-appear-to-class\" (2.1.8+) appear-active-class=\"custom-appear-active-class\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; and custom JavaScript hooks: &lt;transition appear v-on:before-appear=\"customBeforeAppearHook\" v-on:appear=\"customAppearHook\" v-on:after-appear=\"customAfterAppearHook\" v-on:appear-cancelled=\"customAppearCancelledHook\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; Transitioning Between ElementsWe discuss transitioning between components later, but you can also transition between raw elements using v-if/v-else. One of the most common two-element transitions is between a list container and a message describing an empty list: &lt;transition&gt; &lt;table v-if=\"items.length &gt; 0\"&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; This works well, but there’s one caveat to be aware of: When toggling between elements that have the same tag name, you must tell Vue that they are distinct elements by giving them unique key attributes. Otherwise, Vue’s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, it’s considered good practice to always key multiple items within a &lt;transition&gt; component. For example: &lt;transition&gt; &lt;button v-if=\"isEditing\" key=\"save\"&gt; Save &lt;/button&gt; &lt;button v-else key=\"edit\"&gt; Edit &lt;/button&gt;&lt;/transition&gt; In these cases, you can also use the key attribute to transition between different states of the same element. Instead of using v-if and v-else, the above example could be rewritten as: &lt;transition&gt; &lt;button v-bind:key=\"isEditing\"&gt; &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125; &lt;/button&gt;&lt;/transition&gt; It’s actually possible to transition between any number of elements, either by using multiple v-ifs or binding a single element to a dynamic property. For example: &lt;transition&gt; &lt;button v-if=\"docState === 'saved'\" key=\"saved\"&gt; Edit &lt;/button&gt; &lt;button v-if=\"docState === 'edited'\" key=\"edited\"&gt; Save &lt;/button&gt; &lt;button v-if=\"docState === 'editing'\" key=\"editing\"&gt; Cancel &lt;/button&gt;&lt;/transition&gt; Which could also be written as: &lt;transition&gt; &lt;button v-bind:key=\"docState\"&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt; // ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case 'saved': return 'Edit' case 'edited': return 'Save' case 'editing': return 'Cancel' &#125; &#125;&#125; Transition ModesThere’s still one problem though. Try clicking the button below: on off new Vue({ el: '#no-mode-demo', data: { on: false } }) .no-mode-fade-enter-active, .no-mode-fade-leave-active { transition: opacity .5s } .no-mode-fade-enter, .no-mode-fade-leave-active { opacity: 0 } As it’s transitioning between the “on” button and the “off” button, both buttons are rendered - one transitioning out while the other transitions in. This is the default behavior of &lt;transition&gt; - entering and leaving happens simultaneously. Sometimes this works great, like when transitioning items are absolutely positioned on top of each other: on off new Vue({ el: '#no-mode-absolute-demo', data: { on: false } }) .no-mode-absolute-demo-wrapper { position: relative; height: 18px; } .no-mode-absolute-demo-wrapper button { position: absolute; } .no-mode-absolute-fade-enter-active, .no-mode-absolute-fade-leave-active { transition: opacity .5s; } .no-mode-absolute-fade-enter, .no-mode-absolute-fade-leave-active { opacity: 0; } And then maybe also translated so that they look like slide transitions: on off new Vue({ el: '#no-mode-translate-demo', data: { on: false } }) .no-mode-translate-demo-wrapper { position: relative; height: 18px; } .no-mode-translate-demo-wrapper button { position: absolute; } .no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active { transition: all 1s; } .no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active { opacity: 0; } .no-mode-translate-fade-enter { transform: translateX(31px); } .no-mode-translate-fade-leave-active { transform: translateX(-31px); } Simultaneous entering and leaving transitions aren’t always desirable though, so Vue offers some alternative transition modes: in-out: New element transitions in first, then when complete, the current element transitions out. out-in: Current element transitions out first, then when complete, the new element transitions in. Now let’s update the transition for our on/off buttons with out-in: &lt;transition name=\"fade\" mode=\"out-in\"&gt; &lt;!-- ... the buttons ... --&gt;&lt;/transition&gt; on off new Vue({ el: '#with-mode-demo', data: { on: false } }) .with-mode-fade-enter-active, .with-mode-fade-leave-active { transition: opacity .5s } .with-mode-fade-enter, .with-mode-fade-leave-active { opacity: 0 } With one simple attribute addition, we’ve fixed that original transition without having to add any special styling. The in-out mode isn’t used as often, but can sometimes be useful for a slightly different transition effect. Let’s try combining it with the slide-fade transition we worked on earlier: on off new Vue({ el: '#in-out-translate-demo', data: { on: false } }) .in-out-translate-demo-wrapper { position: relative; height: 18px; } .in-out-translate-demo-wrapper button { position: absolute; } .in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active { transition: all .5s; } .in-out-translate-fade-enter, .in-out-translate-fade-leave-active { opacity: 0; } .in-out-translate-fade-enter { transform: translateX(31px); } .in-out-translate-fade-leave-active { transform: translateX(-31px); } Pretty cool, right? Transitioning Between ComponentsTransitioning between components is even simpler - we don’t even need the key attribute. Instead, we just wrap a dynamic component: &lt;transition name=\"component-fade\" mode=\"out-in\"&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/transition&gt; new Vue(&#123; el: '#transition-components-demo', data: &#123; view: 'v-a' &#125;, components: &#123; 'v-a': &#123; template: '&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b': &#123; template: '&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125;&#125;) .component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to/* .component-fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; A B .component-fade-enter-active, .component-fade-leave-active { transition: opacity .3s ease; } .component-fade-enter, .component-fade-leave-to { opacity: 0; } new Vue({ el: '#transition-components-demo', data: { view: 'v-a' }, components: { 'v-a': { template: 'Component A' }, 'v-b': { template: 'Component B' } } }) List TransitionsSo far, we’ve managed transitions for: Individual nodes Multiple nodes where only 1 is rendered at a time So what about for when we have a whole list of items we want to render simultaneously, for example with v-for? In this case, we’ll use the &lt;transition-group&gt; component. Before we dive into an example though, there are a few things that are important to know about this component: Unlike &lt;transition&gt;, it renders an actual element: a &lt;span&gt; by default. You can change the element that’s rendered with the tag attribute. Elements inside are always required to have a unique key attribute List Entering/Leaving TransitionsNow let’s dive into a simple example, transitioning entering and leaving using the same CSS classes we’ve used previously: &lt;div id=\"list-demo\"&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\"&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt; new Vue(&#123; el: '#list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;) .list-item &#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-to /* .list-leave-active below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125; Add Remove {{ item }} new Vue({ el: '#list-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, } }) .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s; } .list-enter, .list-leave-to { opacity: 0; transform: translateY(30px); } There’s one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We’ll fix that later. List Move TransitionsThe &lt;transition-group&gt; component has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of the v-move class, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided name attribute and you can also manually specify a class with the move-class attribute. This class is mostly useful for specifying the transition timing and easing curve, as you’ll see below: &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"flip-list-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;transition-group name=\"flip-list\" tag=\"ul\"&gt; &lt;li v-for=\"item in items\" v-bind:key=\"item\"&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; new Vue(&#123; el: '#flip-list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9] &#125;, methods: &#123; shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;) .flip-list-move &#123; transition: transform 1s;&#125; Shuffle {{ item }} new Vue({ el: '#flip-list-demo', data: { items: [1,2,3,4,5,6,7,8,9] }, methods: { shuffle: function () { this.items = _.shuffle(this.items) } } }) .flip-list-move { transition: transform 1s; } This might seem like magic, but under the hood, Vue is using a simple animation technique called FLIP to smoothly transition elements from their old position to their new position using transforms. We can combine this technique with our previous implementation to animate every possible change to our list! &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"list-complete-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list-complete\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-complete-item\" &gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt; new Vue(&#123; el: '#list-complete-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;) .list-complete-item &#123; transition: all 1s; display: inline-block; margin-right: 10px;&#125;.list-complete-enter, .list-complete-leave-to/* .list-complete-leave-active below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125;.list-complete-leave-active &#123; position: absolute;&#125; Shuffle Add Remove {{ item }} new Vue({ el: '#list-complete-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, shuffle: function () { this.items = _.shuffle(this.items) } } }) .list-complete-item { transition: all 1s; display: inline-block; margin-right: 10px; } .list-complete-enter, .list-complete-leave-to { opacity: 0; transform: translateY(30px); } .list-complete-leave-active { position: absolute; } One important note is that these FLIP transitions do not work with elements set to display: inline. As an alternative, you can use display: inline-block or place elements in a flex context. These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can transitioned just as easily: Lazy Sudoku Keep hitting the shuffle button until you win. Shuffle {{ cell.number }} new Vue({ el: '#sudoku-demo', data: { cells: Array.apply(null, { length: 81 }) .map(function (_, index) { return { id: index, number: index % 9 + 1 } }) }, methods: { shuffle: function () { this.cells = _.shuffle(this.cells) } } }) .sudoku-container { display: flex; flex-wrap: wrap; width: 238px; margin-top: 10px; } .cell { display: flex; justify-content: space-around; align-items: center; width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px; } .cell:nth-child(3n) { margin-right: 0; } .cell:nth-child(27n) { margin-bottom: 0; } .cell-move { transition: transform 1s; } Staggering List TransitionsBy communicating with JavaScript transitions through data attributes, it’s also possible to stagger transitions in a list: &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"staggered-list-demo\"&gt; &lt;input v-model=\"query\"&gt; &lt;transition-group name=\"staggered-fade\" tag=\"ul\" v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;li v-for=\"(item, index) in computedList\" v-bind:key=\"item.msg\" v-bind:data-index=\"index\" &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; new Vue(&#123; el: '#staggered-list-demo', data: &#123; query: '', list: [ &#123; msg: 'Bruce Lee' &#125;, &#123; msg: 'Jackie Chan' &#125;, &#123; msg: 'Chuck Norris' &#125;, &#123; msg: 'Jet Li' &#125;, &#123; msg: 'Kung Fury' &#125; ] &#125;, computed: &#123; computedList: function () &#123; var vm = this return this.list.filter(function (item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 1, height: '1.6em' &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125;&#125;) {{ item.msg }} new Vue({ el: '#example-5', data: { query: '', list: [ { msg: 'Bruce Lee' }, { msg: 'Jackie Chan' }, { msg: 'Chuck Norris' }, { msg: 'Jet Li' }, { msg: 'Kung Fury' } ] }, computed: { computedList: function () { var vm = this return this.list.filter(function (item) { return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 }) } }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.height = 0 }, enter: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity( el, { opacity: 1, height: '1.6em' }, { complete: done } ) }, delay) }, leave: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity( el, { opacity: 0, height: 0 }, { complete: done } ) }, delay) } } }) Reusable TransitionsTransitions can be reused through Vue’s component system. To create a reusable transition, all you have to do is place a &lt;transition&gt; or &lt;transition-group&gt; component at the root, then pass any children into the transition component. Here’s an example using a template component: Vue.component('my-special-transition', &#123; template: '\\ &lt;transition\\ name=\"very-special-transition\"\\ mode=\"out-in\"\\ v-on:before-enter=\"beforeEnter\"\\ v-on:after-enter=\"afterEnter\"\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ ', methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;) And functional components are especially well-suited to this task: Vue.component('my-special-transition', &#123; functional: true, render: function (createElement, context) &#123; var data = &#123; props: &#123; name: 'very-special-transition', mode: 'out-in' &#125;, on: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125; &#125; return createElement('transition', data, context.children) &#125;&#125;) Dynamic TransitionsYes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the name attribute to a dynamic property. &lt;transition v-bind:name=\"transitionName\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; This can be useful when you’ve defined CSS transitions/animations using Vue’s transition class conventions and simply want to switch between them. Really though, any transition attribute can be dynamically bound. And it’s not just attributes. Since event hooks are just methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently. &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"dynamic-fade-demo\"&gt; Fade In: &lt;input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; Fade Out: &lt;input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; &lt;transition v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-on:click=\"stop = true\"&gt;Stop it!&lt;/button&gt;&lt;/div&gt; new Vue(&#123; el: '#dynamic-fade-demo', data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: false &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration, complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration, complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;) Fade In: Fade Out: hello Stop it! new Vue({ el: '#dynamic-fade-demo', data: { show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: false }, mounted: function () { this.show = false }, methods: { beforeEnter: function (el) { el.style.opacity = 0 }, enter: function (el, done) { var vm = this Velocity(el, { opacity: 1 }, { duration: this.fadeInDuration, complete: function () { done() if (!vm.stop) vm.show = false } } ) }, leave: function (el, done) { var vm = this Velocity(el, { opacity: 0 }, { duration: this.fadeOutDuration, complete: function () { done() vm.show = true } } ) } } }) Finally, the ultimate way of creating dynamic transitions is through components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination."},{"title":"Unit Testing","date":"2017-07-23T06:47:55.870Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/unit-testing.html","permalink":"https://rohmikwon.github.io/v2/guide/unit-testing.html","excerpt":"","text":"Setup and ToolingAnything compatible with a module-based build system will work, but if you’re looking for a specific recommendation, try the Karma test runner. It has a lot of community plugins, including support for Webpack and Browserify. For detailed setup, please refer to each project’s respective documentation, though these example Karma configurations for Webpack and Browserify may help you get started. Simple AssertionsIn terms of code structure for testing, you don’t have to do anything special in your components to make them testable. Just export the raw options: &lt;template&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; message: 'hello!' &#125; &#125;, created () &#123; this.message = 'bye!' &#125; &#125;&lt;/script&gt; When you test that component, all you have to do is import the object along with Vue to make many common assertions: // Import Vue and the component being testedimport Vue from 'vue'import MyComponent from 'path/to/MyComponent.vue'// Here are some Jasmine 2.0 tests, though you can// use any test runner / assertion library combo you preferdescribe('MyComponent', () =&gt; &#123; // Inspect the raw component options it('has a created hook', () =&gt; &#123; expect(typeof MyComponent.created).toBe('function') &#125;) // Evaluate the results of functions in // the raw component options it('sets the correct default data', () =&gt; &#123; expect(typeof MyComponent.data).toBe('function') const defaultData = MyComponent.data() expect(defaultData.message).toBe('hello!') &#125;) // Inspect the component instance on mount it('correctly sets the message when created', () =&gt; &#123; const vm = new Vue(MyComponent).$mount() expect(vm.message).toBe('bye!') &#125;) // Mount an instance and inspect the render output it('renders the correct message', () =&gt; &#123; const Ctor = Vue.extend(MyComponent) const vm = new Ctor().$mount() expect(vm.$el.textContent).toBe('bye!') &#125;)&#125;) Writing Testable ComponentsA lot of component’s render output are primarily determined by the props they receive. In fact, if a component’s render output solely depends on its props, it becomes quite straightforward to test, similar to asserting the return value of a pure function with different arguments. Take a contrived example: &lt;template&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: ['msg'] &#125;&lt;/script&gt; You can assert its render output with different props using the propsData option: import Vue from 'vue'import MyComponent from './MyComponent.vue'// helper function that mounts and returns the rendered textfunction getRenderedText (Component, propsData) &#123; const Ctor = Vue.extend(Component) const vm = new Ctor(&#123; propsData: propsData &#125;).$mount() return vm.$el.textContent&#125;describe('MyComponent', () =&gt; &#123; it('renders correctly with different props', () =&gt; &#123; expect(getRenderedText(MyComponent, &#123; msg: 'Hello' &#125;)).toBe('Hello') expect(getRenderedText(MyComponent, &#123; msg: 'Bye' &#125;)).toBe('Bye') &#125;)&#125;) Asserting Asynchronous UpdatesSince Vue performs DOM updates asynchronously, assertions on DOM updates resulting from state change will have to be made in a Vue.nextTick callback: // Inspect the generated HTML after a state updateit('updates the rendered message when vm.message updates', done =&gt; &#123; const vm = new Vue(MyComponent).$mount() vm.message = 'foo' // wait a \"tick\" after state change before asserting DOM updates Vue.nextTick(() =&gt; &#123; expect(vm.$el.textContent).toBe('foo') done() &#125;)&#125;) We are planning to work on a collection of common test helpers that makes it even simpler to render components with different constraints (e.g. shallow rendering that ignores child components) and assert their output."},{"title":"TodoMVC","date":"2017-07-23T06:47:55.849Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/examples/todomvc.html","permalink":"https://rohmikwon.github.io/v2/examples/todomvc.html","excerpt":"","text":"This is a fully spec-compliant TodoMVC implementation in under 120 effective lines of JavaScript (excluding comments and blank lines). Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the localStorage data will fail to be saved from JSFiddle. You’ll have to click on Edit in JSFiddle to see the live result."},{"title":"Template Syntax","date":"2017-07-23T06:47:55.866Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/guide/syntax.html","permalink":"https://rohmikwon.github.io/v2/guide/syntax.html","excerpt":"","text":"Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers. Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal amount of components to re-render and apply the minimal amount of DOM manipulations when the app state changes. If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also directly write render functions instead of templates, with optional JSX support. InterpolationsTextThe most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces): &lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; The mustache tag will be replaced with the value of the msg property on the corresponding data object. It will also be updated whenever the data object’s msg property changes. You can also perform one-time interpolations that do not update on data change by using the v-once directive, but keep in mind this will also affect any binding on the same node: &lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Raw HTMLThe double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the v-html directive: &lt;div v-html=\"rawHtml\"&gt;&lt;/div&gt; The contents of this div will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use v-html to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition. Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided content. AttributesMustaches cannot be used inside HTML attributes, instead use a v-bind directive: &lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; It also works for boolean attributes - the attribute will be removed if the condition evaluates to a falsy value: &lt;button v-bind:disabled=\"isButtonDisabled\"&gt;Button&lt;/button&gt; Using JavaScript ExpressionsSo far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings: &#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain one single expression, so the following will NOT work: &lt;!-- this is a statement, not an expression: --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- flow control won't work either, use ternary expressions --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; Template expressions are sandboxed and only have access to a whitelist of globals such as Math and Date. You should not attempt to access user defined globals in template expressions. DirectivesDirectives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception for v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. Let’s review the example we saw in the introduction: &lt;p v-if=\"seen\"&gt;Now you see me&lt;/p&gt; Here, the v-if directive would remove/insert the &lt;p&gt; element based on the truthiness of the value of the expression seen. ArgumentsSome directives can take an “argument”, denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute: &lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; Here href is the argument, which tells the v-bind directive to bind the element’s href attribute to the value of the expression url. Another example is the v-on directive, which listens to DOM events: &lt;a v-on:click=\"doSomething\"&gt; Here the argument is the event name to listen to. We will talk about event handling in more detail too. ModifiersModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event: &lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; We will see more use of modifiers later when we take a more thorough look at v-on and v-model. FiltersVue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: mustache interpolations and v-bind expressions. Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol: &lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; Vue 2.x filters can only be used inside mustache interpolations and v-bind expressions (the latter supported in 2.1.0+), because filters are primarily designed for text transformation purposes. For more complex data transforms in other directives, you should use Computed properties instead. The filter function always receives the expression’s value as the first argument. new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) Filters can be chained: &#123;&#123; message | filterA | filterB &#125;&#125; Filters are JavaScript functions, therefore they can take arguments: &#123;&#123; message | filterA('arg1', arg2) &#125;&#125; Here, the plain string &#39;arg1&#39; will be passed into the filter as the second argument, and the value of expression arg2 will be evaluated and passed in as the third argument. ShorthandsThe v- prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the v- prefix becomes less important when you are building an SPA where Vue.js manages every template. Therefore, Vue.js provides special shorthands for two of the most often used directives, v-bind and v-on: v-bind Shorthand&lt;!-- full syntax --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- shorthand --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on Shorthand&lt;!-- full syntax --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- shorthand --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; They may look a bit different from normal HTML, but : and @ are valid chars for attribute names and all Vue.js supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later."},{"title":"","date":"2017-07-23T06:47:55.839Z","updated":"2017-07-20T23:46:44.000Z","comments":true,"path":"v2/api/index.html","permalink":"https://rohmikwon.github.io/v2/api/index.html","excerpt":"","text":"Global ConfigVue.config is an object containing Vue’s global configurations. You can modify its properties listed below before bootstrapping your application: silent Type: boolean Default: false Usage: Vue.config.silent = true Suppress all Vue logs and warnings. optionMergeStrategies Type: { [key: string]: Function } Default: {} Usage: Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2 Define custom merging strategies for options. The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument. See also: Custom Option Merging Strategies devtools Type: boolean Default: true (false in production builds) Usage: // make sure to set this synchronously immediately after loading VueVue.config.devtools = true Configure whether to allow vue-devtools inspection. This option’s default value is true in development builds and false in production builds. You can set it to true to enable inspection for production builds. errorHandler Type: Function Default: undefined Usage: Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` is a Vue-specific error info, e.g. which lifecycle hook // the error was found in. Only available in 2.2.0+&#125; Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance. In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is undefined, captured errors will be logged with console.error instead of crashing the app. In 2.4.0+ this hook also captures errors thrown inside Vue custom event handlers. Sentry, an error tracking service, provides official integration using this option. warnHandler New in 2.4.0+ Type: Function Default: undefined Usage: Vue.config.warnHandler = function (msg, vm, trace) &#123; // trace is the component hierarchy trace&#125; Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production. ignoredElements Type: Array&lt;string&gt; Default: [] Usage: Vue.config.ignoredElements = [ 'my-custom-web-component', 'another-web-component'] Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an Unknown custom element, assuming that you forgot to register a global component or misspelled a component name. keyCodes Type: { [key: string]: number | Array&lt;number&gt; } Default: {} Usage: Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase won`t work mediaPlayPause: 179, // instead you can use kebab-case with double quotation marks \"media-play-pause\" : 179, up: [38, 87]&#125; &lt;input type=\"text\" @keyup.media-play-pause=\"method\"&gt; Define custom key alias(es) for v-on. performance New in 2.2.0+ Type: boolean Default: false (from 2.2.3+) Usage: Set this to true to enable component init, compile, render and patch performance tracing in the browser devtool timeline. Only works in development mode and in browsers that support the performance.mark API. productionTip New in 2.2.0+ Type: boolean Default: true Usage: Set this to false to prevent the production tip on Vue startup. Global APIVue.extend( options ) Arguments: {Object} options Usage: Create a “subclass” of the base Vue constructor. The argument should be an object containing component options. The special case to note here is the data option - it must be a function when used with Vue.extend(). &lt;div id=\"mount-point\"&gt;&lt;/div&gt; // create constructorvar Profile = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; return &#123; firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)// create an instance of Profile and mount it on an elementnew Profile().$mount('#mount-point') Will result in: &lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; See also: Components Vue.nextTick( [callback, context] ) Arguments: {Function} [callback] {Object} [context] Usage: Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. // modify datavm.msg = 'Hello'// DOM not updated yetVue.nextTick(function () &#123; // DOM updated&#125;) New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. See also: Async Update Queue Vue.set( target, key, value ) Arguments: {Object | Array} target {string | number} key {any} value Returns: the set value. Usage: Set a property on an object. If the object is reactive, ensure the property is created as a reactive property and trigger view updates. This is primarily used to get around the limitation that Vue cannot detect property additions. Note the object cannot be a Vue instance, or the root data object of a Vue instance. See also: Reactivity in Depth Vue.delete( target, key ) Arguments: {Object | Array} target {string | number} key/index Only works with Array + index in 2.2.0+. Usage: Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it. The target object cannot be a Vue instance, or the root data object of a Vue instance. See also: Reactivity in Depth Vue.directive( id, [definition] ) Arguments: {string} id {Function | Object} [definition] Usage: Register or retrieve a global directive. // registerVue.directive('my-directive', &#123; bind: function () &#123;&#125;, inserted: function () &#123;&#125;, update: function () &#123;&#125;, componentUpdated: function () &#123;&#125;, unbind: function () &#123;&#125;&#125;)// register (simple function directive)Vue.directive('my-directive', function () &#123; // this will be called as `bind` and `update`&#125;)// getter, return the directive definition if registeredvar myDirective = Vue.directive('my-directive') See also: Custom Directives Vue.filter( id, [definition] ) Arguments: {string} id {Function} [definition] Usage: Register or retrieve a global filter. // registerVue.filter('my-filter', function (value) &#123; // return processed value&#125;)// getter, return the filter if registeredvar myFilter = Vue.filter('my-filter') Vue.component( id, [definition] ) Arguments: {string} id {Function | Object} [definition] Usage: Register or retrieve a global component. Registration also automatically sets the component’s name with the given id. // register an extended constructorVue.component('my-component', Vue.extend(&#123; /* ... */ &#125;))// register an options object (automatically call Vue.extend)Vue.component('my-component', &#123; /* ... */ &#125;)// retrieve a registered component (always return constructor)var MyComponent = Vue.component('my-component') See also: Components Vue.use( plugin ) Arguments: {Object | Function} plugin Usage: Install a Vue.js plugin. If the plugin is an Object, it must expose an install method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument. When this method is called on the same plugin multiple times, the plugin will be installed only once. See also: Plugins Vue.mixin( mixin ) Arguments: {Object} mixin Usage: Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. Not recommended in application code. See also: Global Mixins Vue.compile( template ) Arguments: {string} template Usage: Compiles a template string into a render function. Only available in the full build. var res = Vue.compile('&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;')new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) See also: Render Functions Vue.version Details: Provides the installed version of Vue as a string. This is especially useful for community plugins and components, where you might use different strategies for different versions. Usage: var version = Number(Vue.version.split('.')[0])if (version === 2) &#123; // Vue v2.x.x&#125; else if (version === 1) &#123; // Vue v1.x.x&#125; else &#123; // Unsupported versions of Vue&#125; Options / Datadata Type: Object | Function Restriction: Only accepts Function when used in a component definition. Details: The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. The object must be plain: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior. Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance. After the instance is created, the original data object can be accessed as vm.$data. The Vue instance also proxies all the properties found on the data object, so vm.a will be equivalent to vm.$data.a. Properties that start with _ or $ will not be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as vm.$data._property. When defining a component, data must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we still use a plain object for data, that same object will be shared by reference across all instances created! By providing a data function, every time a new instance is created, we can simply call it to return a fresh copy of the initial data. If required, a deep clone of the original object can be obtained by passing vm.$data through JSON.parse(JSON.stringify(...)). Example: var data = &#123; a: 1 &#125;// direct instance creationvar vm = new Vue(&#123; data: data&#125;)vm.a // -&gt; 1vm.$data === data // -&gt; true// must use function when in Vue.extend()var Component = Vue.extend(&#123; data: function () &#123; return &#123; a: 1 &#125; &#125;&#125;) Note that you should not use an arrow function with the data property (e.g. data: () =&gt; { return { a: this.myProp }}). The reason is arrow functions bind the parent context, so this will not be the Vue instance as you expect and this.myProp will be undefined. See also: Reactivity in Depth props Type: Array&lt;string&gt; | Object Details: A list/hash of attributes that are exposed to accept data from the parent component. It has a simple Array-based syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values. Example: // simple syntaxVue.component('props-demo-simple', &#123; props: ['size', 'myMessage']&#125;)// object syntax with validationVue.component('props-demo-advanced', &#123; props: &#123; // just type check height: Number, // type check plus other validations age: &#123; type: Number, default: 0, required: true, validator: function (value) &#123; return value &gt;= 0 &#125; &#125; &#125;&#125;) See also: Props propsData Type: { [key: string]: any } Restriction: only respected in instance creation via new. Details: Pass props to an instance during its creation. This is primarily intended to make unit testing easier. Example: var Comp = Vue.extend(&#123; props: ['msg'], template: '&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'&#125;)var vm = new Comp(&#123; propsData: &#123; msg: 'hello' &#125;&#125;) computed Type: { [key: string]: Function | { get: Function, set: Function } } Details: Computed properties to be mixed into the Vue instance. All getters and setters have their this context automatically bound to the Vue instance. Note that you should not use an arrow function to define a computed property (e.g. aDouble: () =&gt; this.a * 2). The reason is arrow functions bind the parent context, so this will not be the Vue instance as you expect and this.a will be undefined. Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance’s scope (i.e. not reactive), the computed property will not be updated. Example: var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // get only, just need a function aDouble: function () &#123; return this.a * 2 &#125;, // both get and set aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // -&gt; 2vm.aPlus = 3vm.a // -&gt; 2vm.aDouble // -&gt; 4 See also: Computed Properties methods Type: { [key: string]: Function } Details: Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their this context automatically bound to the Vue instance. Note that you should not use an arrow function to define a method (e.g. plus: () =&gt; this.a++). The reason is arrow functions bind the parent context, so this will not be the Vue instance as you expect and this.a will be undefined. Example: var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2 See also: Methods and Event Handling watch Type: { [key: string]: string | Function | Object } Details: An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call $watch() for each entry in the object at instantiation. Example: var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // string method name b: 'someMethod', // deep watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;)vm.a = 2 // -&gt; new: 2, old: 1 Note that you should not use an arrow function to define a watcher (e.g. searchQuery: newValue =&gt; this.updateAutocomplete(newValue)). The reason is arrow functions bind the parent context, so this will not be the Vue instance as you expect and this.updateAutocomplete will be undefined. See also: Instance Methods - vm.$watch Options / DOMel Type: string | HTMLElement Restriction: only respected in instance creation via new. Details: Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement. After the instance is mounted, the resolved element will be accessible as vm.$el. If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call vm.$mount() to manually start the compilation. The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to &lt;html&gt; or &lt;body&gt;. If neither render function nor template option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used. See also: Lifecycle Diagram Runtime + Compiler vs. Runtime-only template Type: string Details: A string template to be used as the markup for the Vue instance. The template will replace the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template. If the string starts with # it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common &lt;script type=&quot;x-template&quot;&gt; trick to include templates. From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template. If render function is present in the Vue option, the template will be ignored. See also: Lifecycle Diagram Content Distribution render Type: (createElement: () =&gt; VNode) =&gt; VNode Details: An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a createElement method as it’s first argument used to create VNodes. If the component is a functional component, the render function also receives an extra argument context, which provides access to contextual data since functional components are instance-less. The render function has priority over the render function compiled from template option or in-DOM HTML template of the mounting element which is specified by the el option. See also: Render Functions renderError New in 2.2.0+ Type: (createElement: () =&gt; VNode, error: Error) =&gt; VNode Details: Only works in development mode. Provide an alternative render output when the default render function encounters an error. The error will be passed to renderError as the second argument. This is particularly useful when used together with hot-reload. Example: new Vue(&#123; render (h) &#123; throw new Error('oops') &#125;, renderError (h, err) &#123; return h('pre', &#123; style: &#123; color: 'red' &#125;&#125;, err.stack) &#125;&#125;).$mount('#app') See also: Render Functions Options / Lifecycle HooksAll lifecycle hooks automatically have their this context bound to the instance, so that you can access data, computed properties, and methods. This means you should not use an arrow function to define a lifecycle method (e.g. created: () =&gt; this.fetchTodos()). The reason is arrow functions bind the parent context, so this will not be the Vue instance as you expect and this.fetchTodos will be undefined. beforeCreate Type: Function Details: Called synchronously after the instance has just been initialized, before data observation and event/watcher setup. See also: Lifecycle Diagram created Type: Function Details: Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the $el property will not be available yet. See also: Lifecycle Diagram beforeMount Type: Function Details: Called right before the mounting begins: the render function is about to be called for the first time. This hook is not called during server-side rendering. See also: Lifecycle Diagram mounted Type: Function Details: Called after the instance has just been mounted where el is replaced by the newly created vm.$el. If the root instance is mounted to an in-document element, vm.$el will also be in-document when mounted is called. This hook is not called during server-side rendering. See also: Lifecycle Diagram beforeUpdate Type: Function Details: Called when the data changes, before the virtual DOM is re-rendered and patched. You can perform further state changes in this hook and they will not trigger additional re-renders. This hook is not called during server-side rendering. See also: Lifecycle Diagram updated Type: Function Details: Called after a data change causes the virtual DOM to be re-rendered and patched. The component’s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it’s usually better to use a computed property or watcher instead. This hook is not called during server-side rendering. See also: Lifecycle Diagram activated Type: Function Details: Called when a kept-alive component is activated. This hook is not called during server-side rendering. See also: Built-in Components - keep-alive Dynamic Components - keep-alive deactivated Type: Function Details: Called when a kept-alive component is deactivated. This hook is not called during server-side rendering. See also: Built-in Components - keep-alive Dynamic Components - keep-alive beforeDestroy Type: Function Details: Called right before a Vue instance is destroyed. At this stage the instance is still fully functional. This hook is not called during server-side rendering. See also: Lifecycle Diagram destroyed Type: Function Details: Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed. This hook is not called during server-side rendering. See also: Lifecycle Diagram Options / Assetsdirectives Type: Object Details: A hash of directives to be made available to the Vue instance. See also: Custom Directives filters Type: Object Details: A hash of filters to be made available to the Vue instance. See also: Vue.filter components Type: Object Details: A hash of components to be made available to the Vue instance. See also: Components Options / Compositionparent Type: Vue instance Details: Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as this.$parent for the child, and the child will be pushed into the parent’s $children array. Use $parent and $children sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication. mixins Type: Array&lt;Object&gt; Details: The mixins option accepts an array of mixin objects. These mixin objects can contain instance options just like normal instance objects, and they will be merged against the eventual options using the same option merging logic in Vue.extend(). e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called. Mixin hooks are called in the order they are provided, and called before the component’s own hooks. Example: var mixin = &#123; created: function () &#123; console.log(1) &#125;&#125;var vm = new Vue(&#123; created: function () &#123; console.log(2) &#125;, mixins: [mixin]&#125;)// -&gt; 1// -&gt; 2 See also: Mixins extends Type: Object | Function Details: Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use Vue.extend. This is primarily intended to make it easier to extend between single file components. This is similar to mixins, the difference being that the component’s own options takes higher priority than the source component being extended. Example: var CompA = &#123; ... &#125;// extend CompA without having to call Vue.extend on eithervar CompB = &#123; extends: CompA, ...&#125; provide / inject New in 2.2.0+ Type: provide: Object | () =&gt; Object inject: Array&lt;string&gt; | { [key: string]: string | Symbol } Details: provide and inject are primarily provided for advanced plugin / component library use cases. It is NOT recommended to use them in generic application code. This pair of options are used together to allow an ancestor component to serve as a dependency injector for its all descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React’s context feature. The provide option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support Symbol and Reflect.ownKeys. The inject options should be either an Array of strings or an object where the keys stand for the local binding name, and the value being the key (string or Symbol) to search for in available injections. Note: the provide and inject bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive. Example: var Provider = &#123; provide: &#123; foo: 'bar' &#125;, // ...&#125;var Child = &#123; inject: ['foo'], created () &#123; console.log(this.foo) // -&gt; \"bar\" &#125; // ...&#125; With ES2015 Symbols, function provide and object inject: const s = Symbol()const Provider = &#123; provide () &#123; return &#123; [s]: 'foo' &#125; &#125;&#125;const Child = &#123; inject: &#123; s &#125;, // ...&#125; The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the props and the data initialization. Using an injected value as the default for a prop: const Child = &#123; inject: ['foo'], props: &#123; bar: &#123; default () &#123; return this.foo &#125; &#125; &#125;&#125; Using an injected value as data entry: const Child = &#123; inject: ['foo'], data () &#123; return &#123; bar: this.foo &#125; &#125;&#125; Options / Miscname Type: string Restriction: only respected when used as a component option. Details: Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with Vue.component(), the global ID is automatically set as its name. Another benefit of specifying a name option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the vue-devtools, unnamed components will show up as &lt;AnonymousComponent&gt;, which isn’t very informative. By providing the name option, you will get a much more informative component tree. delimiters Type: Array&lt;string&gt; Default: [\"{{\", \"}}\"] Restrictions: This option is only available in the full build, with in-browser compilation. Details: Change the plain text interpolation delimiters. Example: new Vue(&#123; delimiters: ['$&#123;', '&#125;']&#125;)// Delimiters changed to ES6 template string style functional Type: boolean Details: Causes a component to be stateless (no data) and instanceless (no this context). They are simply a render function that returns virtual nodes making them much cheaper to render. See also: Functional Components model New in 2.2.0 Type: { prop?: string, event?: string } Details: Allows a custom component to customize the prop and event used when it’s used with v-model. By default, v-model on a component uses value as the prop and input as the event, but some input types such as checkboxes and radio buttons may want to use the value prop for a different purpose. Using the model option can avoid the conflict in such cases. Example: Vue.component('my-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; // this allows using the `value` prop for a different purpose value: String, // use `checked` as the prop which take the place of `value` checked: &#123; type: Number, default: 0 &#125; &#125;, // ...&#125;) &lt;my-checkbox v-model=\"foo\" value=\"some value\"&gt;&lt;/my-checkbox&gt; The above will be equivalent to: &lt;my-checkbox :checked=\"foo\" @change=\"val =&gt; &#123; foo = val &#125;\" value=\"some value\"&gt;&lt;/my-checkbox&gt; inheritAttrs New in 2.4.0+ Type: boolean Default: true Details: By default, parent scope attribute bindings that are not recognized as props will “fallthrough” and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting inheritAttrs to false, this default behavior can be disabled. The attributes are available via the $attrs instance property (also new in 2.4) and can be explicitly bound to a non-root element using v-bind. Note: this option does not affect class and style bindings. comments New in 2.4.0+ Type: boolean Default: false Restrictions: This option is only available in the full build, with in-browser compilation. Details: When set to true, will preserve and render HTML comments found in templates. The default behavior is discarding them. Instance Propertiesvm.$data Type: Object Details: The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object. See also: Options - data vm.$props New in 2.2.0+ Type: Object Details: An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object. vm.$el Type: HTMLElement Read only Details: The root DOM element that the Vue instance is managing. vm.$options Type: Object Read only Details: The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options: new Vue(&#123; customOption: 'foo', created: function () &#123; console.log(this.$options.customOption) // -&gt; 'foo' &#125;&#125;) vm.$parent Type: Vue instance Read only Details: The parent instance, if the current instance has one. vm.$root Type: Vue instance Read only Details: The root Vue instance of the current component tree. If the current instance has no parents this value will be itself. vm.$children Type: Array&lt;Vue instance&gt; Read only Details: The direct child components of the current instance. Note there’s no order guarantee for $children, and it is not reactive. If you find yourself trying to use $children for data binding, consider using an Array and v-for to generate child components, and use the Array as the source of truth. vm.$slots Type: { [name: string]: ?Array&lt;VNode&gt; } Read only Details: Used to programmatically access content distributed by slots. Each named slot has its own corresponding property (e.g. the contents of slot=&quot;foo&quot; will be found at vm.$slots.foo). The default property contains any nodes not included in a named slot. Accessing vm.$slots is most useful when writing a component with a render function. Example: &lt;blog-post&gt; &lt;h1 slot=\"header\"&gt; About Me &lt;/h1&gt; &lt;p&gt;Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.&lt;/p&gt; &lt;p slot=\"footer\"&gt; Copyright 2016 Evan You &lt;/p&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt; Vue.component('blog-post', &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement('div', [ createElement('header', header), createElement('main', body), createElement('footer', footer) ]) &#125;&#125;) See also: &lt;slot&gt; Component Content Distribution with Slots Render Functions: Slots vm.$scopedSlots New in 2.1.0+ Type: { [name: string]: props =&gt; VNode | Array&lt;VNode&gt; } Read only Details: Used to programmatically access scoped slots. For each slot, including the default one, the object contains a corresponding function that returns VNodes. Accessing vm.$scopedSlots is most useful when writing a component with a render function. See also: &lt;slot&gt; Component Scoped Slots Render Functions: Slots vm.$refs Type: Object Read only Details: An object that holds child components that have ref registered. See also: Child Component Refs ref vm.$isServer Type: boolean Read only Details: Whether the current Vue instance is running on the server. See also: Server-Side Rendering vm.$attrs Type: { [key: string]: string } Read only Details: Contains parent-scope attribute bindings (except for class and style) that are not recognized (and extracted) as props. When a component doesn’t have any declared props, this essentially contains all parent-scope bindings (except for class and style), and can be passed down to an inner component via v-bind=&quot;$attrs&quot; - useful when creating higher-order components. vm.$listeners Type: { [key: string]: Function | Array&lt;Function&gt; } Read only Details: Contains parent-scope v-on event listeners (without .native modifiers). This can be passed down to an inner component via v-on=&quot;$listeners&quot; - useful when creating higher-order components. Instance Methods / Datavm.$watch( expOrFn, callback, [options] ) Arguments: {string | Function} expOrFn {Function | Object} callback {Object} [options] {boolean} deep {boolean} immediate Returns: {Function} unwatch Usage: Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts simple dot-delimited paths. For more complex expression, use a function instead. Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value. Example: // keypathvm.$watch('a.b.c', function (newVal, oldVal) &#123; // do something&#125;)// functionvm.$watch( function () &#123; return this.a + this.b &#125;, function (newVal, oldVal) &#123; // do something &#125;) vm.$watch returns an unwatch function that stops firing the callback: var unwatch = vm.$watch('a', cb)// later, teardown the watcherunwatch() Option: deep To also detect nested value changes inside Objects, you need to pass in deep: true in the options argument. Note that you don’t need to do so to listen for Array mutations. vm.$watch('someObject', callback, &#123; deep: true&#125;)vm.someObject.nestedValue = 123// callback is fired Option: immediate Passing in immediate: true in the option will trigger the callback immediately with the current value of the expression: vm.$watch('a', callback, &#123; immediate: true&#125;)// callback is fired immediately with current value of `a` vm.$set( target, key, value ) Arguments: {Object | Array} target {string | number} key {any} value Returns: the set value. Usage: This is the alias of the global Vue.set. See also: Vue.set vm.$delete( target, key ) Arguments: {Object | Array} target {string | number} key Usage: This is the alias of the global Vue.delete. See also: Vue.delete Instance Methods / Eventsvm.$on( event, callback ) Arguments: {string | Array&lt;string&gt;} event (array only supported in 2.2.0+) {Function} callback Usage: Listen for a custom event on the current vm. Events can be triggered by vm.$emit. The callback will receive all the additional arguments passed into these event-triggering methods. Example: vm.$on('test', function (msg) &#123; console.log(msg)&#125;)vm.$emit('test', 'hi')// -&gt; \"hi\" vm.$once( event, callback ) Arguments: {string} event {Function} callback Usage: Listen for a custom event, but only once. The listener will be removed once it triggers for the first time. vm.$off( [event, callback] ) Arguments: {string} [event] {Function} [callback] Usage: Remove custom event listener(s). If no arguments are provided, remove all event listeners; If only the event is provided, remove all listeners for that event; If both event and callback are given, remove the listener for that specific callback only. vm.$emit( event, […args] ) Arguments: {string} event [...args] Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function. Instance Methods / Lifecyclevm.$mount( [elementOrSelector] ) Arguments: {Element | string} [elementOrSelector] {boolean} [hydrating] Returns: vm - the instance itself Usage: If a Vue instance didn’t receive the el option at instantiation, it will be in “unmounted” state, without an associated DOM element. vm.$mount() can be used to manually start the mounting of an unmounted Vue instance. If elementOrSelector argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself. The method returns the instance itself so you can chain other instance methods after it. Example: var MyComponent = Vue.extend(&#123; template: '&lt;div&gt;Hello!&lt;/div&gt;'&#125;)// create and mount to #app (will replace #app)new MyComponent().$mount('#app')// the above is the same as:new MyComponent(&#123; el: '#app' &#125;)// or, render off-document and append afterwards:var component = new MyComponent().$mount()document.getElementById('app').appendChild(component.$el) See also: Lifecycle Diagram Server-Side Rendering vm.$forceUpdate() Usage: Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content. vm.$nextTick( [callback] ) Arguments: {Function} [callback] Usage: Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global Vue.nextTick, except that the callback’s this context is automatically bound to the instance calling this method. New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Example: new Vue(&#123; // ... methods: &#123; // ... example: function () &#123; // modify data this.message = 'changed' // DOM is not updated yet this.$nextTick(function () &#123; // DOM is now updated // `this` is bound to the current instance this.doSomethingElse() &#125;) &#125; &#125;&#125;) See also: Vue.nextTick Async Update Queue vm.$destroy() Usage: Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners. Triggers the beforeDestroy and destroyed hooks. In normal use cases you shouldn’t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using v-if and v-for. See also: Lifecycle Diagram Directivesv-text Expects: string Details: Updates the element’s textContent. If you need to update the part of textContent, you should use {{ Mustache }} interpolations. Example: &lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;!-- same as --&gt;&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; See also: Data Binding Syntax - interpolations v-html Expects: string Details: Updates the element’s innerHTML. Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates. If you find yourself trying to compose templates using v-html, try to rethink the solution by using components instead. Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS attacks. Only use v-html on trusted content and never on user-provided content. Example: &lt;div v-html=\"html\"&gt;&lt;/div&gt; See also: Data Binding Syntax - interpolations v-show Expects: any Usage: Toggle’s the element’s display CSS property based on the truthy-ness of the expression value. This directive triggers transitions when its condition changes. See also: Conditional Rendering - v-show v-if Expects: any Usage: Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a &lt;template&gt; element, its content will be extracted as the conditional block. This directive triggers transitions when its condition changes. When used together with v-if, v-for has a higher priority than v-if. See the list rendering guide for details. See also: Conditional Rendering - v-if v-else Does not expect expression Restriction: previous sibling element must have v-if or v-else-if. Usage: Denote the “else block” for v-if or a v-if/v-else-if chain. &lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; See also: Conditional Rendering - v-else v-else-if New in 2.1.0+ Expects: any Restriction: previous sibling element must have v-if or v-else-if. Usage: Denote the “else if block” for v-if. Can be chained. &lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; See also: Conditional Rendering - v-else-if v-for Expects: Array | Object | number | string Usage: Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax alias in expression to provide an alias for the current element being iterated on: &lt;div v-for=\"item in items\"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; Alternatively, you can also specify an alias for the index (or the key if used on an Object): &lt;div v-for=\"(item, index) in items\"&gt;&lt;/div&gt;&lt;div v-for=\"(val, key) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"(val, key, index) in object\"&gt;&lt;/div&gt; The default behavior of v-for will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the key special attribute: &lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &#123;&#123; item.text &#125;&#125;&lt;/div&gt; When used together with v-if, v-for has a higher priority than v-if. See the list rendering guide for details. The detailed usage for v-for is explained in the guide section linked below. See also: List Rendering key v-on Shorthand: @ Expects: Function | Inline Statement | Object Argument: event Modifiers: .stop - call event.stopPropagation(). .prevent - call event.preventDefault(). .capture - add event listener in capture mode. .self - only trigger handler if event was dispatched from this element. .{keyCode | keyAlias} - only trigger handler on certain keys. .native - listen for a native event on the root element of component. .once - trigger handler at most once. .left - (2.2.0+) only trigger handler for left button mouse events. .right - (2.2.0+) only trigger handler for right button mouse events. .middle - (2.2.0+) only trigger handler for middle button mouse events. .passive - (2.3.0+) attaches a DOM event with { passive: true }. Usage: Attaches an event listener to the element. The event type is denoted by the argument. The expression can either be a method name or an inline statement, or simply omitted when there are modifiers present. Starting in 2.4.0+, v-on also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers. When used on a normal element, it listens to native DOM events only. When used on a custom element component, it also listens to custom events emitted on that child component. When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special $event property: v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;. Example: &lt;!-- method handler --&gt;&lt;button v-on:click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- object syntax (2.4.0+) --&gt;&lt;button v-on=\"&#123; mousedown: doThis, mouseup: doThat &#125;\"&gt;&lt;/button&gt;&lt;!-- inline statement --&gt;&lt;button v-on:click=\"doThat('hello', $event)\"&gt;&lt;/button&gt;&lt;!-- shorthand --&gt;&lt;button @click=\"doThis\"&gt;&lt;/button&gt;&lt;!-- stop propagation --&gt;&lt;button @click.stop=\"doThis\"&gt;&lt;/button&gt;&lt;!-- prevent default --&gt;&lt;button @click.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- prevent default without expression --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- chain modifiers --&gt;&lt;button @click.stop.prevent=\"doThis\"&gt;&lt;/button&gt;&lt;!-- key modifier using keyAlias --&gt;&lt;input @keyup.enter=\"onEnter\"&gt;&lt;!-- key modifier using keyCode --&gt;&lt;input @keyup.13=\"onEnter\"&gt;&lt;!-- the click event will be triggered at most once --&gt;&lt;button v-on:click.once=\"doThis\"&gt;&lt;/button&gt; Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child): &lt;my-component @my-event=\"handleThis\"&gt;&lt;/my-component&gt;&lt;!-- inline statement --&gt;&lt;my-component @my-event=\"handleThis(123, $event)\"&gt;&lt;/my-component&gt;&lt;!-- native event on component --&gt;&lt;my-component @click.native=\"onClick\"&gt;&lt;/my-component&gt; See also: Methods and Event Handling Components - Custom Events v-bind Shorthand: : Expects: any (with argument) | Object (without argument) Argument: attrOrProp (optional) Modifiers: .prop - Bind as a DOM property instead of an attribute (what’s the difference?). If the tag is a component then .prop will set the property on the component’s $el. .camel - (2.1.0+) transform the kebab-case attribute name into camelCase. .sync - (2.3.0+) a syntax sugar that expands into a v-on handler for updating the bound value. Usage: Dynamically bind one or more attributes, or a component prop to an expression. When used to bind the class or style attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details. When used for prop binding, the prop must be properly declared in the child component. When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode class and style does not support Array or Objects. Example: &lt;!-- bind an attribute --&gt;&lt;img v-bind:src=\"imageSrc\"&gt;&lt;!-- shorthand --&gt;&lt;img :src=\"imageSrc\"&gt;&lt;!-- with inline string concatenation --&gt;&lt;img :src=\"'/path/to/images/' + fileName\"&gt;&lt;!-- class binding --&gt;&lt;div :class=\"&#123; red: isRed &#125;\"&gt;&lt;/div&gt;&lt;div :class=\"[classA, classB]\"&gt;&lt;/div&gt;&lt;div :class=\"[classA, &#123; classB: isB, classC: isC &#125;]\"&gt;&lt;!-- style binding --&gt;&lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;&lt;/div&gt;&lt;div :style=\"[styleObjectA, styleObjectB]\"&gt;&lt;/div&gt;&lt;!-- binding an object of attributes --&gt;&lt;div v-bind=\"&#123; id: someProp, 'other-attr': otherProp &#125;\"&gt;&lt;/div&gt;&lt;!-- DOM attribute binding with prop modifier --&gt;&lt;div v-bind:text-content.prop=\"text\"&gt;&lt;/div&gt;&lt;!-- prop binding. \"prop\" must be declared in my-component. --&gt;&lt;my-component :prop=\"someThing\"&gt;&lt;/my-component&gt;&lt;!-- pass down parent props in common with a child component --&gt;&lt;child-component v-bind=\"$props\"&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=\"foo\"&gt;&lt;/a&gt;&lt;/svg&gt; The .camel modifier allows camelizing a v-bind attribute name when using in-DOM templates, e.g. the SVG viewBox attribute: &lt;svg :view-box.camel=\"viewBox\"&gt;&lt;/svg&gt; .camel is not needed if you are using string templates, or compiling with vue-loader/vueify. See also: Class and Style Bindings Components - Component Props Components - .sync Modifier v-model Expects: varies based on value of form inputs element or output of components Limited to: &lt;input&gt; &lt;select&gt; &lt;textarea&gt; components Modifiers: .lazy - listen to change events instead of input .number - cast input string to numbers .trim - trim input Usage: Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below. See also: Form Input Bindings Components - Form Input Components using Custom Events v-pre Does not expect expression Usage: Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation. Example: &lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt; v-cloak Does not expect expression Usage: This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as [v-cloak] { display: none }, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready. Example: [v-cloak] &#123; display: none;&#125; &lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; The &lt;div&gt; will not be visible until the compilation is done. v-once Does not expect expression Details: Render the element and component once only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance. &lt;!-- single element --&gt;&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;!-- the element have children --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- component --&gt;&lt;my-component v-once :comment=\"msg\"&gt;&lt;/my-component&gt;&lt;!-- v-for directive --&gt;&lt;ul&gt; &lt;li v-for=\"i in list\" v-once&gt;&#123;&#123;i&#125;&#125;&lt;/li&gt;&lt;/ul&gt; See also: Data Binding Syntax - interpolations Components - Cheap Static Components with v-once Special Attributeskey Expects: string The key special attribute is primarily used as a hint for Vue’s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed. Children of the same common parent must have unique keys. Duplicate keys will cause render errors. The most common use case is combined with v-for: &lt;ul&gt; &lt;li v-for=\"item in items\" :key=\"item.id\"&gt;...&lt;/li&gt;&lt;/ul&gt; It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to: Properly trigger lifecycle hooks of a component Trigger transitions For example: &lt;transition&gt; &lt;span :key=\"text\"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; When text changes, the &lt;span&gt; will always be replaced instead of patched, so a transition will be triggered. ref Expects: string ref is used to register a reference to an element or a child component. The reference will be registered under the parent component’s $refs object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance: &lt;!-- vm.$refs.p will be the DOM node --&gt;&lt;p ref=\"p\"&gt;hello&lt;/p&gt;&lt;!-- vm.$refs.child will be the child comp instance --&gt;&lt;child-comp ref=\"child\"&gt;&lt;/child-comp&gt; When used on elements/components with v-for, the registered reference will be an Array containing DOM nodes or component instances. An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! $refs is also non-reactive, therefore you should not attempt to use it in templates for data-binding. See also: Child Component Refs slot Expects: string Used on content inserted into child components to indicate which named slot the content belongs to. For detailed usage, see the guide section linked below. See also: Named Slots is Expects: string Used for dynamic components and to work around limitations of in-DOM templates. For example: &lt;!-- component changes when currentView changes --&gt;&lt;component v-bind:is=\"currentView\"&gt;&lt;/component&gt;&lt;!-- necessary because &lt;my-row&gt; would be invalid inside --&gt;&lt;!-- a &lt;table&gt; element and so would be hoisted out --&gt;&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; For detailed usage, follow the links in the description above. See also: Dynamic Components DOM Template Parsing Caveats Built-In Componentscomponent Props: is - string | ComponentDefinition | ComponentConstructor inline-template - boolean Usage: A “meta component” for rendering dynamic components. The actual component to render is determined by the is prop: &lt;!-- a dynamic component controlled by --&gt;&lt;!-- the `componentId` property on the vm --&gt;&lt;component :is=\"componentId\"&gt;&lt;/component&gt;&lt;!-- can also render registered component or component passed as prop --&gt;&lt;component :is=\"$options.components.child\"&gt;&lt;/component&gt; See also: Dynamic Components transition Props: name - string, Used to automatically generate transition CSS class names. e.g. name: &#39;fade&#39; will auto expand to .fade-enter, .fade-enter-active, etc. Defaults to &quot;v&quot;. appear - boolean, Whether to apply transition on initial render. Defaults to false. css - boolean, Whether to apply CSS transition classes. Defaults to true. If set to false, will only trigger JavaScript hooks registered via component events. type - string, Specify the type of transition events to wait for to determine transition end timing. Available values are &quot;transition&quot; and &quot;animation&quot;. By default, it will automatically detect the type that has a longer duration. mode - string, Controls the timing sequence of leaving/entering transitions. Available modes are &quot;out-in&quot; and &quot;in-out&quot;; defaults to simultaneous. enter-class - string leave-class - string appear-class - string enter-to-class - string leave-to-class - string appear-to-class - string enter-active-class - string leave-active-class - string appear-active-class - string Events: before-enter before-leave before-appear enter leave appear after-enter after-leave after-appear enter-cancelled leave-cancelled (v-show only) appear-cancelled Usage: &lt;transition&gt; serve as transition effects for single element/component. The &lt;transition&gt; does not render an extra DOM element, nor does it show up in the inspected component hierarchy. It simply applies the transition behavior to the wrapped content inside. &lt;!-- simple element --&gt;&lt;transition&gt; &lt;div v-if=\"ok\"&gt;toggled content&lt;/div&gt;&lt;/transition&gt;&lt;!-- dynamic component --&gt;&lt;transition name=\"fade\" mode=\"out-in\" appear&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/transition&gt;&lt;!-- event hooking --&gt;&lt;div id=\"transition-demo\"&gt; &lt;transition @after-enter=\"transitionComplete\"&gt; &lt;div v-show=\"ok\"&gt;toggled content&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; new Vue(&#123; ... methods: &#123; transitionComplete: function (el) &#123; // for passed 'el' that DOM element as the argument, something ... &#125; &#125; ...&#125;).$mount('#transition-demo') See also: Transitions: Entering, Leaving, and Lists transition-group Props: tag - string, defaults to span. move-class - overwrite CSS class applied during moving transition. exposes the same props as &lt;transition&gt; except mode. Events: exposes the same events as &lt;transition&gt;. Usage: &lt;transition-group&gt; serve as transition effects for multiple elements/components. The &lt;transition-group&gt; renders a real DOM element. By default it renders a &lt;span&gt;, and you can configure what element is should render via the tag attribute. Note every child in a &lt;transition-group&gt; must be uniquely keyed for the animations to work properly. &lt;transition-group&gt; supports moving transitions via CSS transform. When a child’s position on screen has changed after an updated, it will get applied a moving CSS class (auto generated from the name attribute or configured with the move-class attribute). If the CSS transform property is “transition-able” when the moving class is applied, the element will be smoothly animated to its destination using the FLIP technique. &lt;transition-group tag=\"ul\" name=\"slide\"&gt; &lt;li v-for=\"item in items\" :key=\"item.id\"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; See also: Transitions: Entering, Leaving, and Lists keep-alive Props: include - string or RegExp or Array. Only components matched by this will be cached. exclude - string or RegExp or Array. Any component matched by this will not be cached. Usage: When wrapped around a dynamic component, &lt;keep-alive&gt; caches the inactive component instances without destroying them. Similar to &lt;transition&gt;, &lt;keep-alive&gt; is an abstract component: it doesn’t render a DOM element itself, and doesn’t show up in the component parent chain. When a component is toggled inside &lt;keep-alive&gt;, its activated and deactivated lifecycle hooks will be invoked accordingly. In 2.2.0+ and above, activated and deactivated will fire for all nested components inside a &lt;keep-alive&gt; tree. Primarily used with preserve component state or avoid re-rendering. &lt;!-- basic --&gt;&lt;keep-alive&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- multiple conditional children --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=\"a &gt; 1\"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- used together with &lt;transition&gt; --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; Note, &lt;keep-alive&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have v-for inside it. When there are multiple conditional children, as above, &lt;keep-alive&gt; requires that only one child is rendered at a time. include and exclude New in 2.1.0+ The include and exclude props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array: &lt;!-- comma-delimited string --&gt;&lt;keep-alive include=\"a,b\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- regex (use v-bind) --&gt;&lt;keep-alive :include=\"/a|b/\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (use v-bind) --&gt;&lt;keep-alive :include=\"['a', 'b']\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; The match is first checked on the component’s own name option, then its local registration name (the key in the parent’s components option) if the name option is not available. Anonymous components cannot be matched against. &lt;keep-alive&gt; does not work with functional components because they do not have instances to be cached. See also: Dynamic Components - keep-alive slot Props: name - string, Used for named slot. Usage: &lt;slot&gt; serve as content distribution outlets in component templates. &lt;slot&gt; itself will be replaced. For detailed usage, see the guide section linked below. See also: Content Distribution with Slots VNode Interface Please refer to the VNode class declaration. Server-Side Rendering Please refer to the vue-server-renderer package documentation."}],"posts":[{"title":"Hello","slug":"Hello","date":"2017-07-23T20:00:19.000Z","updated":"2017-07-23T20:17:01.454Z","comments":true,"path":"2017/07/24/Hello/","link":"","permalink":"https://rohmikwon.github.io/2017/07/24/Hello/","excerpt":"","text":"hexo 기반 블로그 입니다.","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://rohmikwon.github.io/tags/hexo/"}]}]}